\documentclass{article}
\usepackage{ctex}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{amsmath,amssymb,amsfonts}%equation need this 
\usepackage{bm}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{graphicx} %插入图片的宏包
\usepackage{float} %设置图片浮动位置的宏包
\usepackage{subfigure} %插入多图时用子图显示的宏包
\usepackage[a4paper, left = 10mm, right = 10mm, top = 15mm, bottom = 15mm]{geometry}

\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\green}[1]{{\color{green}{#1}}}
\newcommand{\yellow}[1]{{\color{yellow}{#1}}}
\newcommand{\orange}[1]{{\color{orange}{#1}}}
\newcommand{\blue}[1]{{\color{blue}{#1}}}
\newcommand{\pink}[1]{{\color{pink}{#1}}}
\newcommand{\tiffany}[1]{{\color{tiffany}{#1}}}
\newcommand{\purple}[1]{{\color{purple}{#1}}}
\newcommand{\darkgray}[1]{{\color{darkgray}{#1}}}
\newcommand{\p}{\par }
\newcommand{\pl}{\par \ \par}
\newcommand{\s}[1]{${#1}$}

\definecolor{tiffany}{RGB}{127, 208, 201}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
%    numbers=left,
%    numberstyle=\footnotesize,
%    numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\title{Vue笔记}
\author{曹思远}
\date{\today}
\begin{document}
\maketitle
\tableofcontents
\newpage
\begin{abstract}
    vue笔记
\end{abstract}

\section{起手式}
\subsection{Vue自学路线图}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/vuelearn.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{Vue自学路线图} %最终文档中希望显示的图片标题
\end{figure}
\subsection{项目搭建}
\red{搞出一个使用Vue的项目}
\subsubsection{两种方法}
\begin{enumerate}
    \item \orange{方法一: 使用@vue/cli}
          \begin{itemize}
              \item 搜索@vue/cli，进入官网
              \item 打开文档，打开创建一个项目章节
          \end{itemize}
    \item \orange{方法二: 自己从零搭建Vue项目}
          \begin{itemize}
              \item 使用webpack或者rollup从零开始
              \item 适合老手
          \end{itemize}
\end{enumerate}
\subsubsection{@vue/cli用法}
\begin{enumerate}
    \item 全局安装：yarn global add @vue/cli
    \item 创建目录：vue create路径 (路径可以用.点)
    \item 选择使用哪些配置
    \item 进入目录，运行yarn serve开启webpack-dev-server
    \item 用WebStorm或VSCode打开项目开始干
    \item 进入@vue/cli官网看目录
\end{enumerate}
\subsubsection{安装Vue的选项}
\begin{enumerate}
    \item 选错了请Ctrl+C中断然后重来
    \item 没有截图的都使用默认选项
    \item 真实项目自行斟酌
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/vue0.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              %\caption{Vue自学路线图} %最终文档中希望显示的图片标题
          \end{figure}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/vue1.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              %\caption{Vue自学路线图} %最终文档中希望显示的图片标题
          \end{figure}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/vue3.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              %\caption{Vue自学路线图} %最终文档中希望显示的图片标题
          \end{figure}
    \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-demo-0}{vue demo地址}}}
\end{enumerate}
\subsection{Vue实例}
\red{很重要，做项目必须用到}
\subsubsection{如何使用Vue实例}
\begin{enumerate}
    \item \orange{方法一: 从HTML得到视图}
          \begin{itemize}
              \item 也就是文档里说的完整版Vue
              \item 从CDN引入vue.js或vue.min.js
              \item 也可以通过import引入vue.js或者vue.min.js
              \item 完整版视图支持从html引入
              \item 也可以用template写在js里面
              \item 完整版不好的地方是给用户的体积变大了
          \end{itemize}
    \item \orange{方法二: 用JS构建视图}
          \begin{itemize}
              \item 使用vue.runtime.js，也就是非完整版
              \item 不支持从html里获得视图，template也不行
              \item 这种方法不方便，但实际是对的
              \item 必须要用render(createElement)的方式把所有元素构造出来
                    \begin{lstlisting}
                new Vue({
                    el: "#app",
                    render(createElement) {
                        const h = createElement;
                        return h('div', [this.n, h('button', {
                            on:{click:this.add}, '+1'
                        })])
                    },
                    data: {
                        n: 0
                    },
                    methods: {
                        add() {
                            this.n += 1
                        }
                    }
                })
            \end{lstlisting}
              \item 好处是更加的独立，不需要编译器，减少百分之30的体积
          \end{itemize}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/runtimevue.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{完整版与不完整版的区别} %最终文档中希望显示的图片标题
          \end{figure}
    \item \orange{方法三:使用vue-loader}
          \begin{itemize}
              \item 可以把.vue文件以及其template里的东西翻译成h构建方法
              \item 但这样做HTML就只有一个div\#app，SEO不友好
              \item 通过webpack让用户写的时候是完整版，但实际下载的时候是非完整版
          \end{itemize}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/webpackvue.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{用webpack通过vue-loader转化减少代码体积} %最终文档中希望显示的图片标题
          \end{figure}
\end{enumerate}
\subsubsection{Vue实例的作用}
\begin{enumerate}
    \item \orange{Vue实例就如同jQuery实例}
          \begin{itemize}
              \item 封装了对DOM的所有操作
              \item 封装了对data的所有操作
          \end{itemize}
    \item \orange{操作DOM}
          \begin{itemize}
              \item 无非就是监听事件，改变DOM
          \end{itemize}
    \item \orange{操作data}
          \begin{itemize}
              \item 无非就是增删改查
              \item Vue2还有一个bug(面试考，在后面响应式原理里)
          \end{itemize}
    \item \orange{没有封装ajax}
          \begin{itemize}
              \item 用axios的ajax功能
          \end{itemize}
\end{enumerate}
\subsubsection{SEO基本原理}
\begin{enumerate}
    \item \orange{seo友好}
          \begin{itemize}
              \item 搜索引擎优化
              \item 你可以认为搜索引擎就是不停地curl
              \item 搜索引擎根据curl结果猜测页面内容
              \item 如果你的页面都是用JS创建的div，那么curl就很瞎
          \end{itemize}
    \item \orange{那怎么办}
          \begin{itemize}
              \item 给curl一点内容
              \item 把title，description, keyword, h1, a写好即可
              \item 原则：让curl能得到页面的信息，seo就能正常工作
          \end{itemize}
\end{enumerate}
\subsection{理解两种vue的区别}
\subsubsection{深入理解}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/diffvue.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{两种vue版本的区别} %最终文档中希望显示的图片标题
\end{figure}
\subsubsection{引用错了会怎样}
\begin{enumerate}
    \item \orange{vue.js错用成了vue.runtime.js}
          \begin{itemize}
              \item 无法将HTML编译成视图
          \end{itemize}
    \item \orange{vue.runtime.js错用成vue.js}
          \begin{itemize}
              \item 代码体积变大，因为vue.js有编译HTML的功能
          \end{itemize}
\end{enumerate}
\section{构造选项}
\subsection{new Vue里有什么}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/vuememory.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{实例的内存图} %最终文档中希望显示的图片标题
\end{figure}
\subsection{options里有什么}
\subsubsection{options里的五类属性}
\begin{enumerate}
    \item \orange{数据}
          \begin{itemize}
              \item \red{data, props}, \blue{propsData}, \yellow{computed}, \red{methods}, \yellow{watch}
          \end{itemize}
    \item \orange{DOM}
          \begin{itemize}
              \item \red{el}, \purple{template}, \blue{render}, \green{renderError}
          \end{itemize}
    \item \orange{生命周期钩子}
          \begin{itemize}
              \item \green{beforeCreate}, \red{created}, \green{beforeMount}, \red{mounted}, \green{beforeUpdate}, \red{updated}
              \item \yellow{activated}, \yellow{deactivated}, \green{beforeDestroy},  \red{destroyed},  errorCaptured
          \end{itemize}
    \item \orange{资源}
          \begin{itemize}
              \item \yellow{directives}, \purple{filters}, \red{components}
          \end{itemize}
    \item \orange{组合}
          \begin{itemize}
              \item parent, \yellow{mixins, extends, provide, inject}
          \end{itemize}
\end{enumerate}
\subsubsection{属性分段}
\begin{enumerate}
    \item \red{红色属性(9)}
          \begin{itemize}
              \item 好学，必学，几句话就能说明白
          \end{itemize}
    \item \yellow{黄色属性(9)}
          \begin{itemize}
              \item 高级属性，稍微费点力
          \end{itemize}
    \item \green{绿色属性(5)}
          \begin{itemize}
              \item 简单
          \end{itemize}
    \item \blue{蓝色属性(2)}
          \begin{itemize}
              \item 不常用，可学可不学
          \end{itemize}
    \item \purple{紫色属性(2)}
          \begin{itemize}
              \item 比较特殊，重点
          \end{itemize}
    \item 黑色属性(3)
          \begin{itemize}
              \item 很不常用，用的时候看一下文档
          \end{itemize}
\end{enumerate}
\subsubsection{入门属性}
\red{重点！}
\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-demo-0}{演示代码地址}}}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/vueoptions.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{代码演示结果} %最终文档中希望显示的图片标题
\end{figure}
\begin{enumerate}
    \item \orange{el - 挂载点}
          \begin{itemize}
              \item 可以用\$mount代替
          \end{itemize}
    \item \orange{data - 内部数据}
          \begin{itemize}
              \item 支持对象和函数，优先用函数，如果不这样，组件间就会共用data
          \end{itemize}
    \item \orange{methods - 方法}
          \begin{itemize}
              \item 事件处理函数或者是普通函数
              \item 每次执行都会调用，可能是毫无意义的，这个时候就需要computed
          \end{itemize}
    \item \orange{components}
          \begin{itemize}
              \item Vue组件，注意大小写
              \item 三种引入方式，优先使用模块化
          \end{itemize}
    \item \orange{四个钩子}
          \begin{itemize}
              \item created - 实例出现在内存中
              \item mounted - 实例出现在页面中
              \item updated - 实例更新了
              \item destroyed - 实例从页面和内存中消亡了(具体看代码演示)
          \end{itemize}
    \item \orange{props - 外部数据}
          \begin{itemize}
              \item 也叫属性
              \item message='n'传入字符串
              \item :message='n'传入this.n数据
              \item :fn='add'传入this.add函数
          \end{itemize}
\end{enumerate}
\section{数据响应式}
\subsection{Vue对data做了什么}
\subsubsection{小实验}
\begin{enumerate}
    \item \orange{data变了}
          \begin{itemize}
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index0.html}{示例代码}}}
              \item myData居然变了
              \item 一开始是\{n:0\},传给new Vue之后立马变成\{n:(...)\}
              \item \{n:(...)\}是个什么玩意，为什么表现和\{n:0\}一致？
              \item 需要先学习一下es6的\yellow{getter和setter}
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index1.html}{示例代码}}}
              \item 理解{n:(...)}还需要学习一下\yellow{Object.defineProperty}
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index2.html}{示例代码}}}
              \item 代理模式继续理解
              \item 注意代码思路，研究方法比知识本身更重要，不读源码也能了解真相
          \end{itemize}
\end{enumerate}
\subsubsection{小结}
\begin{enumerate}
    \item \orange{Object.defineProperty}
          \begin{itemize}
              \item 可以给对象添加属性value
              \item 可以给对象添加getter/setter
              \item getter/setter用于对属性的读写进行监控
          \end{itemize}
    \item \orange{啥是代理(设计模式)}
          \begin{itemize}
              \item 对myData对象的属性读写，全权由另一个对象vm负责
              \item 那么vm就是myData的代理(类比房东租房)
              \item 比如myData.n不用，便要用vm.n来操作myData.n
          \end{itemize}
    \item \orange{vm=new Vue(\{data:myData\})}
          \begin{itemize}
              \item 一，会让vm成为myData的代理(proxy)
              \item 二，会对myData的所有属性进行监控
              \item 为什么要监控，为了防止myData的属性变了，vm不知道
              \item vm知道了又如何？知道属性变了就可以调用render(data)呀！
              \item UI=render(data)
          \end{itemize}
\end{enumerate}
\subsubsection{示意图}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/data-response.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{如果data有多个属性n,m,k, 那么就会有get n/get m/get k等} %最终文档中希望显示的图片标题
\end{figure}
\subsection{深入理解数据响应式}
\begin{enumerate}
    \item \orange{什么是响应式}
          \begin{itemize}
              \item 我打你一拳，你会喊疼，那你就是响应式的
              \item 若一个物体能对外界的刺激做出反应，它就是响应式的
          \end{itemize}
    \item \orange{Vue的data是响应式}
          \begin{itemize}
              \item const vm = new Vue({data:{n:0}})
              \item 我如果修改vm.n，那么UI中的n就会响应我
              \item Vue2通过Object.defineProperty来实现数据响应式
          \end{itemize}
\end{enumerate}
\subsection{Vue的bug}
\begin{enumerate}
    \item \orange{Object.defineProperty的问题}
          \begin{itemize}
              \item Object.defineProperty(obj, 'n', \{...\})
              \item 必须要有一个'n'，才能监听\&代理obj.n
              \item 如果前端开发者比较水，没有给n怎么办
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index3.html}{示例一}}}
              \item 如果data为空，不会显示undefined或null，只会给出一个警告
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index4.html}{示例二}}}
              \item Vue只会检查第一层属性
              \item 此时如果我点击set b，请问视图中会显示1吗？
              \item 答案是：不会
              \item 为什么：因为Vue没办法监听一开始不存在的obj.b
          \end{itemize}
    \item \orange{解决办法}
          \begin{itemize}
              \item 一，那我把key都声明好，后面不再加属性不就行了
              \item 使用Vue.set或者this.\$set
          \end{itemize}
\end{enumerate}
\subsubsection{Vue.set和this.\$set}
\begin{enumerate}
    \item \orange{作用}
          \begin{itemize}
              \item 新增key
              \item 自动创建代理和监听(如果没有创建过)
              \item 触发UI更新(但并不会立即更新)
          \end{itemize}
    \item \orange{举例}
          \begin{itemize}
              \item this.\$set(this.object, 'm', 100)
          \end{itemize}
\end{enumerate}
\subsubsection{data中有数组怎么办？}
\begin{enumerate}
    \item \orange{你没法提前声明所有key}
          \begin{itemize}
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index5.html}{示例代码}}}
              \item 数组的长度可以一直增加，下标就是key
              \item 你看，你没有办法提前把数组的key都声明出来
              \item Vue也不能检测对你新增了下标
              \item 难道每次改数组都要用Vue.set或者this.\$set
          \end{itemize}
    \item \orange{尤雨溪的做法}
          \begin{itemize}
              \item 篡改数组的API，见vue文档中变异方法章节
              \item 这7个API都会被Vue篡改，调用后会更新UI
              \item 如何篡改见下面代码
          \end{itemize}
\end{enumerate}
\subsubsection{ES6写法}
\yellow{注：这不代表Vue的真实实现，但基本思路是这样，程序员不需要看源码也能实现出来的}
\begin{lstlisting}
    class VueArray extends Array {
        push(...args) {
            const oldLength = this.length //this 就是当前数组
            super.push(...args)
            console.log('你push了')
            for(let i = oldLength; i < this.length; i++) {
                Vue.set(this, i, this[i])
                //将每个新增的key都告诉Vue
            }
        }
    }
\end{lstlisting}
\subsubsection{ES5写法-原型}
\yellow{这个需要前端基础笔记中原型链的知识}
\begin{lstlisting}
    const vueArrayPrototype = {
        push: function() {
            console.log('你push了')
            return Array.prototype.push.apply(this, arguments)
        }
    }
    vueArrayPrototype.__proto__ = Array.prototype
    //上面这句话用的不是标准属性，仅学习使用

    const array = Object.create(vueArrayPrototype)
    array.push(1)
\end{lstlisting}
\subsection{总结}
\begin{enumerate}
    \item \orange{对象中新增的key}
          \begin{itemize}
              \item Vue没有办法事先监听和代理
              \item 要使用set来新增key，创建监听和代理，更新UI
              \item 最好提前把属性都写出来，不要新增key
              \item 但数组做不到不新增key
          \end{itemize}
    \item \orange{数组中新增的key}
          \begin{itemize}
              \item 也可用set来新增key，更新UI
              \item 不过尤雨溪篡改了7个API方便你对数组进行增删
              \item 这7个API会\yellow{自动处理监听和代理}，并更新UI
              \item 结论：数组新增key最好通过7个API
          \end{itemize}
\end{enumerate}
\subsection{刁钻的题}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/vuebug.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{刁钻的题} %最终文档中希望显示的图片标题
\end{figure}
\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-data-response/index6.html}{刁钻的题目代码地址}}}
\begin{enumerate}
    \item \orange{分析}
          \begin{itemize}
              \item span-b 之所以会显示 b，是因为视图在显示 span-a 的 a2 时，顺便更新了 span-b
          \end{itemize}
    \item \orange{要理解为什么 span-b 会更新，要点是理解视图更新其实是异步的。}
          \begin{itemize}
              \item 当我们让 a 从 'a1' 变成 'a2' 时，Vue 会监听到这个变化，
              \item 但是 Vue 并不能马上更新视图，因为 Vue 是使用 Object.defineProperty 这样的方式来监听变化的，
              \item 监听到变化后会创建一个视图更新任务到任务队列里。（文档有写）
              \item 所以在视图更新之前，要先把余下的代码运行完才行，也就是会运行 b = `b'
              \item 等到视图更新的时候，由于 Vue 会去做 diff（文档有写）
              \item 于是 Vue 就会发现 a 和 b 都变了，自然会去更新 span-a 和 span-b
          \end{itemize}
\end{enumerate}
\section{computed和watch}
\subsection{进阶属性}
\begin{enumerate}
    \item \orange{computed - 计算属性}
          \begin{itemize}
              \item 不需要加括号
              \item 它会根据依赖是否变化来缓存
          \end{itemize}
    \item \orange{watch - 监听}
          \begin{itemize}
              \item 一旦data变化，就执行的函数
              \item options.watch用法
              \item this.\$watch用法
              \item deep, immediate含义
          \end{itemize}
    \item \orange{directives - 指令}
          \begin{itemize}
              \item 内置指令v-if/v-for/v-bind/v-on
              \item 自定义指令，如v-focus
              \item 指令是为了\yellow{减少重复}的DOM操作
          \end{itemize}
    \item \orange{mixin - 混入}
          \begin{itemize}
              \item 重复三次之后的出路
              \item 混入v.s.全局混入
              \item 选项自动合并
              \item 混入就是为了\yellow{减少重复}的构造选项
          \end{itemize}
    \item \orange{extends - 继承}
          \begin{itemize}
              \item 先了解一下Vue.extend
              \item 你觉得用了mixin还是重复
              \item 于是你自己写了一个View,它继承Vue
              \item 你还可以预先定义其他构造选项
              \item 那为什么不用ES6的extends呢？
          \end{itemize}
    \item \orange{provide/inject}
          \begin{itemize}
              \item 爷爷想和孙子讲话怎么办
              \item 祖宗想跟它的所有后代讲话怎么办
              \item 答案是全局变量，但是全局变量太low
              \item 所以我们需要\red{局部的}\yellow{全局变量}
          \end{itemize}
\end{enumerate}
\subsection{复习一下响应式原理}
\begin{enumerate}
    \item \orange{options.data}
          \begin{itemize}
              \item 会被Vue监听
              \item 会被Vue实例代理
              \item 每次对data的读写都会被Vue监控
              \item Vue会在data变化时更新UI
          \end{itemize}
    \item \orange{本节内容}
          \begin{itemize}
              \item data变化时除了更新UI,还能做点啥？
          \end{itemize}
\end{enumerate}
\subsection{computed - 计算属性}
\begin{enumerate}
    \item \orange{用途}
          \begin{itemize}
              \item 被计算出来的属性就是\yellow{计算属性}
              \item 例1：\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index0.html}{用户名展示}}}
              \item 例2：\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index1.html}{列表展示不用computed}}}
              \item 例3：\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index2.html}{列表展示用computed}}}
          \end{itemize}
    \item \orange{缓存}
          \begin{itemize}
              \item 如果依赖的属性没有变化，就不会重新计算
              \item getter/setter默认不会做缓存，Vue做了特殊处理
              \item 如何缓存？看\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index3.html}{缓存示例}}}(仅供参考学习，不代表Vue真实实现)
          \end{itemize}
\end{enumerate}
\subsection{Watch - 监听}
\begin{enumerate}
    \item \orange{用途}
          \begin{itemize}
              \item 当数据变化时，执行一个函数
              \item 例1：\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index4.html}{异步撤销}}}
              \item 例2：\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index5.html}{模拟computed}}}说实话，这样做很傻
          \end{itemize}
    \item \orange{何谓变化？}
          \begin{itemize}
              \item 看\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-computed-watch/index6.html}{示例}}}
              \item obj原本是\{a:'a'\}, 现在obj=\{a:'a'\}, 请问
              \item obj变了没有？变了。obj.a变了没有？，没变。
              \item 简单类型看值，复杂类型(对象)看地址
              \item 这其实就是===的规则
          \end{itemize}
    \item \orange{语法}
          \begin{itemize}
              \item 语法1
                    \begin{lstlisting}
                watch: {
                //o1: ()=>{} //别用这种，这里的this是全局对象
                o2: function(value, oldValue){},
                o3(){},
                o4: [f1, f2],
                o5: 'methodName',
                o6: {handler:fn, deep:true, immediate:true},
                'object.a': function() {}
                } 
            \end{lstlisting}
              \item 语法2
                    \begin{lstlisting}
                            vm.$watch('xxx', fn, {deep: .., immediate: ..})
                            //其中'xxx'可以改为一个返回字符串的函数
                        \end{lstlisting}
          \end{itemize}
    \item \orange{deep:true是干什么的}
          \begin{itemize}
              \item 如果object.a变了，请问object算不算也变了
              \item 如果你选哟答案式也变了，那么就用deep:true
              \item 如果你需要答案是没有变，那么就用deep:false
              \item deep的意思是，监听object的时候是否往深了看
          \end{itemize}
\end{enumerate}
\section{模板，指令与修饰符}
\subsection{模板template三种写法}
\begin{enumerate}
    \item \orange{一，Vue完整版吗，写在HTML里}
          \begin{lstlisting}
                <div id=xxx>
                    {{n}}
                    <button @click="add">+1</button>
                </div>

                new Vue({
                    el: '#xxx',
                    data:{n:0}, //data可以改成函数
                    method:{add(){}}
                })
            \end{lstlisting}
    \item \orange{二，Vue完整版，写在选项里}
          \begin{lstlisting}
            <div id=app>
            </div>

            new Vue({
                template: `
                    <div>
                        {{n}}
                        <button @click="add">+1</button>
                    </div>`,
                data:{n:0}, //data可以改成函数
                methods:{add(){ this.n += 1 }}
            }).$mount('#app')
        //注意一个细节: div#app会被替代
          \end{lstlisting}
    \item \orange{三，非Vue完整版，配合xxx.vue文件}
          \begin{lstlisting}
            <template>
                <div>
                    {{n}}
                    <button @click="add">
                    +1
                    </button>
                </div>
            </template>
            <script>
                export default {
                    data() { return {n:0} },
                    //data必须为函数
                    methods:{add(){ this.n += 1 }}
                }
            </script>
            <style>这里写CSS</style>
            //然后在另一个地方写如下代码
            import xxx from './xxx.vue'
            //xxx 是一个options对象
            new Vue({
                render: h => h(xxx)
            }).$mount('#app')
          \end{lstlisting}
\end{enumerate}
\subsection{模板里有哪些语法}
\orange{我们把HTML模板叫做template}
\subsubsection{展示内容}
\begin{enumerate}
    \item \orange{表达式}
          \begin{itemize}
              \item \{\{ object.a \}\} 表达式
              \item \{\{ n + 1 \}\} 可以写任何运算
              \item \{\{ fn(n) \}\} 可以调用函数
              \item 如果值为 undefined 或 null 就不显示
              \item 另一种写法为 <div v-text=``表达式''></div> (这种写法没有意义，大家都用上面的)
          \end{itemize}
    \item \orange{HTML内容}
          \begin{itemize}
              \item 假设 data.x 值为 <strong>hi</strong>
              \item <div v-html=``x''></div> 即可显示粗体 hi
          \end{itemize}
    \item \orange{我就想展示 {{ n }}}
          \begin{itemize}
              \item <div v-pre>\{\{ n \}\}</div>
              \item v-pre 不会对模板进行编译
          \end{itemize}
\end{enumerate}
\subsubsection{绑定属性}
\begin{enumerate}
    \item \orange{绑定src}
          \begin{itemize}
              \item <img v-bind:src=``x'' />
          \end{itemize}
    \item \orange{v-bind:简写为:}
          \begin{itemize}
              \item <img :src=``x'' />
          \end{itemize}
    \item \orange{绑定对象}
          \begin{itemize}
              \item <div :style=``{border: `1px solid red', height:100}''注意这里可以把`100px'写成100</div>
          \end{itemize}
\end{enumerate}
\subsubsection{绑定事件}
\begin{enumerate}
    \item \orange{v-on:事件名}
          \begin{itemize}
              \item <button v-on:click=``add''>+1</button> 点击之后，Vue会运行add()
              \item <button v-on:click=``xxx(1)''>xxx</button> 点击之后，Vue会运行xxx(1)
              \item <button v-on:click=``n+=1''>+1</button> 点击之后，Vue会运行n+=1
              \item 点击之后，Vue会运行n+=1，即发现\yellow{函数}就加括号调用之，否则直接运行代码
              \item 这导致一个问题，如果xxx(1)返回一个函数咋办
              \item \yellow{答：用Vue的人怎么可能想出这么复杂的用法}
          \end{itemize}
    \item \orange{缩写}
          \begin{itemize}
              \item <button @click=``n+=1''>+1</button>
              \item 正常人都用缩写
          \end{itemize}
\end{enumerate}
\subsubsection{条件判断}
% \begin{enumerate}
% \item 
\orange{if...else}
\begin{lstlisting}
            <div v-if="x > 0">
              x大于0
            </div>
            <div v-else-if="x===0">
              x为0
            </div>
            <div v-else>
              x小于0
            </div>
      \end{lstlisting}
% \end{enumerate}
\subsubsection{循环}
% \begin{enumerate}
% \item 
\orange{for(value, key) in 对象或数组}
\begin{lstlisting}
            <ul>
                <li v-for="(u,index) in users" :key="index">
                    索引: {{index}} 值: {{u.name}}
                </li>
            </ul>
            <ul>
                <li v-for="(value, name) in obj" :key="name">
                    属性名: {{name}} 属性值: {{name}}
                </li>
            </ul>
          \end{lstlisting}
% \end{enumerate}
\p
坑预警: \yellow{:key=``index''有bug，后面讲}
\subsubsection{显示隐藏}
\begin{enumerate}
    \item \orange{v-show}
          \begin{lstlisting} 
            <div v-show="n\%2===0'"> n 是偶数 </div> 
        \end{lstlisting}
          高手一般不用，用css切换
    \item \orange{近似等于}
          \begin{itemize}
              \begin{lstlisting}
    <div :style="{display:n%2===0?'block':'none'}"> n 是偶数 </div> 
        \end{lstlisting}
              \item 但你要注意，看得见的元素display不只有block
              \item 如table的display为table
              \item 如li的display为list-item
          \end{itemize}
\end{enumerate}
\subsection{总结}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.3\textwidth]{image/template.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{总结} %最终文档中希望显示的图片标题
\end{figure}
\orange{Vue模板主要特点有}
\begin{itemize}
    \item 使用XML语法(不是HTML)
    \item 使用\{\{\}\}插入表达式
    \item 使用v-html v-on v-bind等指令操作DOM
    \item 使用v-if v-for等指令实现条件判断和循环
    \item v-if是什么时候出现在dom树里，v-show是什么时候展示出来(css隐藏的)
\end{itemize}
\subsection{指令Directive}
\subsubsection{指令}
\begin{enumerate}
    \item \orange{什么是指令}
          \begin{lstlisting} 
            <div v-text="x"></div>
            <div v-html="x"></div> 
        \end{lstlisting}
          以\yellow{v-}开头的东西就是指令
    \item \orange{语法}
          \begin{itemize}
              \item v-\green{指令名}:\blue{参数}=\red{值}，如v-\green{on}:\blue{click}=\red{add}
              \item 如果\red{值}里没有特殊字符，则可以不加引号
              \item 有些指令没有参数和值，如 v-pre
              \item 有些指令没有值，如 v-on:click.prevent
          \end{itemize}
\end{enumerate}
\subsubsection{修饰符}
\begin{enumerate}
    \item \orange{有些指令支持修饰符}
          \begin{itemize}
              \item @click.stop=``add''表示阻止事件传播/冒泡
              \item @click.prevent=``add''表示阻止默认动作\quad\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-model/index0.html}{代码示例}}}
              \item @click.stop.prevent=``add''同时表示两种意思
          \end{itemize}
    \item \orange{一共有多少修饰符呢？}
          \begin{itemize}
              \item v-on支持的有\red{.{keycode|keyAlias}}\quad\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-model/index1.html}{代码示例}}}
              \item \red{.stop.prevent}.capture.self.once.passive.native
              \item 快捷键相关.ctrl.alt.shift.meta.exact
              \item 鼠标相关.left.right.middle
              \item v-bind支持的有.prop.camel\red{.sync}
              \item v-model支持的有\purple{.lazy.number.trim}
          \end{itemize}
\end{enumerate}
\subsubsection{.sync修饰符}
\begin{enumerate}
    \item \orange{场景描述}
          \begin{itemize}
              \item 爸爸给儿子钱，儿子要花钱怎么办 \quad\tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-model/vue-sync}{代码示例}}}
              \item 答: 儿子打电话(触发事件)向爸爸要钱
              \item Vue规则:组件不能修改props外部数据
              \item Vue规则:this.\$emit可以触发事件，并传参
              \item Vue规则:\$event可以获取\$emit的参数
          \end{itemize}
    \item \orange{由于这种场景很场景}
          \begin{itemize}
              \item 所以尤雨溪发明了.sync，示例
              \item :money.sync=``total''等价于
              \item :money=``total''v-on:update:money=``total=\$event''
          \end{itemize}
\end{enumerate}
\subsubsection{搞清楚这4个修饰符就行了}
\begin{enumerate}
    \item @click.stop=``xxx''
    \item @click.prevent=``xxx''
    \item @keypress.enter=``xxx''
    \item :money.sync=``total''
\end{enumerate}
\section{进阶构造属性}
\yellow{directive, mixins, extends, provide, inject}
\subsection{Directives}
\yellow{指令}
\subsubsection{自义定指令}
\begin{enumerate}
    \item \orange{我们已经学了一些内置指令}
          \begin{itemize}
              \item v-if v-for v-show v-html等
          \end{itemize}
    \item \orange{今天学习如何自己造一个指令}
          \begin{itemize}
              \item 目标：造出v-x，点击即出现一个x
          \end{itemize}
\end{enumerate}
\subsubsection{两种写法}
\begin{enumerate}
    \item \orange{一，声明一个全局指令}
          \begin{itemize}
              \item Vue.directive('x', directiveOptions)你就可以在任何组件里用v-x了
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-advanced-attr/index0.html}{代码示例}}}
          \end{itemize}
    \item \orange{二，声明一个局部指令}
          \begin{lstlisting}
            new Vue({
                ...,
                directives: {
                    "x": directiveOptions
                }
            })
            //v-x只能用在该实例中
          \end{lstlisting}
\end{enumerate}
\subsubsection{directiveOptions}
\begin{enumerate}
    \item \orange{五个函数属性}
          \begin{itemize}
              \item bind(el, info, vnode, oldVnode) - 类似created
              \item inserted(参数同上) - 类似mounted
              \item update(参数同上) - 类似updated
              \item componentUpdated(参数同上) - 用的不多
              \item unbind(参数同上) - 类似destroyed
          \end{itemize}
    \item \orange{自制v-on2指令，模仿v-on}
          \begin{itemize}
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/blob/master/VUE/vue-advanced-attr/index1.html}{代码地址}}}
          \end{itemize}
\end{enumerate}
\subsubsection{指令的作用}
\begin{enumerate}
    \item \orange{主要用于DOM操作}
          \begin{itemize}
              \item Vue实例/组件用于数据绑定，事件监听，DOM更新
              \item Vue指令主要目的就是原生DOM操作
          \end{itemize}
    \item \orange{减少重复}
          \begin{itemize}
              \item 如果某个DOM操作你经常使用，就可以封装为指令
              \item 如果某个DOM操作比较复杂，也可以封装为指令
          \end{itemize}
\end{enumerate}
\subsection{mixins}
\yellow{混入，混入就是TM复制，前端就喜欢把简单概念搞复杂}
\subsubsection{减少重复}
\begin{enumerate}
    \item \orange{类比}
          \begin{itemize}
              \item directives的作用是减少DOM操作的重复
              \item mixins的作用是减少data, methods, 钩子的重复
          \end{itemize}
    \item \orange{场景描述}
          \begin{itemize}
              \item 假设我们需要在每个组件上添加name和time
              \item 在created, beforeDestroy时，打出提示，并报出存活时间
              \item 一共由五个组件，请问你怎么做？
              \item 一，给每个组件添加data和钩子，共5次
              \item 二，或者使用mixins减少重复
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-advanced-attr/vue-mixin-extends-provide-inject}{已完成的示例地址}}}
          \end{itemize}
    \item \orange{mixins技巧}
          \begin{itemize}
              \item 选项智能合并
              \item Vue.mixin全局使用(不推荐)
          \end{itemize}
\end{enumerate}
\subsection{extends}
\yellow{继承，extends是比mixins更抽象一点的封装}
\yellow{如果你嫌写五次mixins麻烦，可以考虑extends一次，不过实际工作中用得很少}
\subsubsection{减少重复}
\begin{enumerate}
    \item \orange{与mixins同样的需求}
          \begin{itemize}
              \item 不想要每次都写一个mixins，咋办？
              \item 你可以使用Vue.extend或options.extends
          \end{itemize}
    \item \orange{代码演示}
          \begin{lstlisting}
            const MyVue = Vue.extend({
                data(){ return {name:'',time:undefined} },
                created(){
                if(!this.name){console.error('no name!')}
                this.time = new Date()
                },
                beforeDestroy(){
                const duration = (new Date()) - this.time
                console.log(`${this.name} ${duration}`)
                }
            })
            //然后我们就可以使用new MyVue(options)了
          \end{lstlisting}
    \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-advanced-attr/vue-mixin-extends-provide-inject}{完整代码地址}}}
\end{enumerate}
\subsection{provide和inject}
\yellow{提供和注入}
\subsubsection{使用举例}
\begin{enumerate}
    \item \orange{需求}
          \begin{itemize}
              \item 一键换肤功能:默认蓝色，可以切换为红色
              \item 文字大小:默认正常，可以改成大或小
              \item \tiffany{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/VUE/vue-advanced-attr/vue-mixin-extends-provide-inject}{已完成的示例}}}
              \item 祖先栽树(provide)，后人乘凉(inject)
          \end{itemize}
    \item \orange{总结}
          \begin{itemize}
              \item 作用:大范围的data和method等共用
              \item 注意:不能只传themeName不传changeTheme，因为themeName的值是被复制给provide的
              \item 思考:传引用可以吗？可以，但是不推荐，因为容易失控
          \end{itemize}
\end{enumerate}
\subsection{总结}
\begin{enumerate}
    \item \orange{directives指令}
          \begin{itemize}
              \item 全局用Vue.directive('x',{...})
              \item 局部用options.directives
              \item 作用是减少DOM操作相关重复代码
          \end{itemize}
    \item \orange{mixins混入}
          \begin{itemize}
              \item 全局用Vue.mixin({...})
              \item 局部用options.mixins:[mixin1, mixin2]
              \item 作用是减少options里的重复
          \end{itemize}
    \item \orange{extends继承/扩展}
          \begin{itemize}
              \item 全局用Vue.extend({...})
              \item 局部用options.extends:{...}
              \item 作用跟mixins差不多，只是形式不同
          \end{itemize}
    \item \orange{provide/inject提供和注入}
          \begin{itemize}
              \item 祖先提供东西，后代注入东西
              \item 作用是大范围，隔N代共享信息
          \end{itemize}
\end{enumerate}
\section{表单与v-model}
\section{Vue Router-前端路由实现思路}
\section{深入理解Vue动画原理}
\end{document}