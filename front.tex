\documentclass{article}
\usepackage{ctex}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{amsmath,amssymb,amsfonts}%equation need this 
\usepackage{bm}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{graphicx} %插入图片的宏包
\usepackage{float} %设置图片浮动位置的宏包
\usepackage{subfigure} %插入多图时用子图显示的宏包
\usepackage[a4paper, left = 10mm, right = 10mm, top = 15mm, bottom = 15mm]{geometry}

\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\green}[1]{{\color{green}{#1}}}
\newcommand{\yellow}[1]{{\color{yellow}{#1}}}
\newcommand{\orange}[1]{{\color{orange}{#1}}}
\newcommand{\blue}[1]{{\color{blue}{#1}}}
\newcommand{\pink}[1]{{\color{pink}{#1}}}
\newcommand{\tiffany}[1]{{\color{tiffany}{#1}}}
\newcommand{\p}{\par }
\newcommand{\pl}{\par \ \par}
\newcommand{\s}[1]{${#1}$}

\definecolor{tiffany}{RGB}{127, 208, 201}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
%    numbers=left,
%    numberstyle=\footnotesize,
%    numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\title{前端基础笔记}
\author{曹思远}
\date{\today}
\begin{document}
\maketitle
\tableofcontents
\newpage
\begin{abstract}
    前端基础笔记
\end{abstract}
\section{软件安装与配置}
\red{任何软件都需要配置}
% \begin{lstlisting}[caption=My Javascript Example]
%     Name.prototype = {
%       methodName: function(params){
%         var doubleQuoteString = "some text";
%         var singleQuoteString = 'some more text';
%         // this is a comment
%         if(this.confirmed != null && typeof(this.confirmed) == Boolean && this.confirmed == true){
%           document.createElement('h3');
%           $('#system').append("This looks great");
%           return false;
%         } else {
%           throw new Error;
%         }
%       }
%     }
%     \end{lstlisting}
% \subsection{必备软件列表}
% \begin{enumerate}
%     \item vscode, webstorm
%     \item cmder, 7-zip, everything
%     \item chrome, PS, texlive
%     \item clash, sumatraPDF, Snipaste
%     \item NodeJS, Yarn, python
% \end{enumerate}
% \subsubsection{必备软件配置}
% \red{任何软件都需要配置}
% \paragraph{vscode}
% \begin{enumerate}
%     \item 必备插件
%           \begin{itemize}
%               \item Chinese (Simplified) Language Pack for Visual Studio Code
%               \item Code Spell Checker
%               \item Git Easy
%               \item Latex Workshop
%               \item Markdown All in One
%               \item Prettier - Code formatter
%           \end{itemize}
%     \item 环境和快捷键配置
%           \begin{itemize}
%               \item 具体看我知乎保存的setting.json 和 keybinding.json
%           \end{itemize}
%     \item 快捷键
%           \begin{itemize}
%               \item ctrl + p - 找文件
%               \item ctrl + shift + p 或 F1 - 输命令
%               \item alt + 单击 - 多位置输入
%           \end{itemize}
% \end{enumerate}
% \paragraph{cmder}
% \begin{enumerate}
%     \item 配置内容较多，直接看我保存的配置文件。
%     \item 将cmder加入右键菜单，加入环境变量。
% \end{enumerate}
% \paragraph{chrome}
% \begin{enumerate}
%     \item 可选插件
%           \begin{itemize}
%               \item Proxy SwitchOmega
%               \item uBlock
%           \end{itemize}
%     \item 高级用户配置
%           \begin{itemize}
%               \item 在开发者工具\red{里面}按ESC可以新建控制台
%               \item Sources面板可以保存代码片段(Snippets)
%               \item Network关掉show overview，filter可以搜素，右击勾选Method
%               \item Network可模拟慢网速/断网
%               \item Preserve log不会清空当前请求数据
%               \item Disable cache清除缓存
%           \end{itemize}
%     \item chrome常用快捷键
%           \begin{itemize}
%               \item 鼠标中键单击 - 打开或关闭
%               \item ctrl + T - 新开标签
%               \item ctrl + shift + T - 撤销关闭
%               \item ctrl + 点击 - 在新标签打开
%               \item ctrl + W - 关闭当前标签
%               \item ctrl + Reload 或者 F5 - 刷新
%               \item ctrl + Location - 输入网址
%               \item ctrl + shift + Inspector 或 F12 - 打开开发者工具
%               \item alt + 左右 - 前进后退
%               \item alt + 回车 - 在新标签打开
%               \item shift + 回车 - 在新窗口打开
%               \item ctrl + shift + delete - 删除历史浏览数据
%           \end{itemize}
% \end{enumerate}
% \paragraph{windows}
% \begin{enumerate}
%     \item 关掉任务栏无用标签，卸载无用软件。(如搜索框，任务视图，微软小娜Cortana，开始菜单里的各种贴图)
%     \item 可安装TranslucentTB使任务栏透明
%     \item 理解用户目录，即 C:\verb|\|Users\verb|\|Jony，分别右击用户目录里的下载和文件，属性-->位置-->移动到E盘。
%     \item 显示文件后缀，打开查看-->选项-->查看，去掉隐藏已知文件扩展名，勾选显示已知文件，文件夹和驱动器。
%     \item 记住组合键\begin{itemize}
%               \item Win组合键
%                     \begin{enumerate}
%                         \item win + Desktop - 展示桌面
%                         \item win + 方向键 - 移动窗口
%                         \item alt + tab - 切换窗口
%                         \item win + tab - 不怎么常用的切换窗口
%                         \item win + ctrl + 方向键 - 切换桌面
%                     \end{enumerate}
%               \item Ctrl组合键
%                     \begin{enumerate}
%                         \item ctrl + All/ctrl + Copy/ctrl + V/ctrl + Z/ctrl + Y
%                         \item ctrl + Reload/F5
%                         \item ctrl + P - 打印
%                     \end{enumerate}
%           \end{itemize}
% \end{enumerate}
% \paragraph{NodeJS, Yarn}
% \begin{enumerate}
%     \item 开发必装的东西
%           \begin{itemize}
%               \item nrm
%               \item tldr
%           \end{itemize}
% \end{enumerate}
\section{Git入门}
\subsection{命令行入门}
\subsection{本地仓库}
\subsection{远程仓库}
\section{HTML}
\subsection{概览}
\subsection{标签}
\subsection{重难点}
\subsection{实践和手机调试}
\section{CSS}
\subsection{基础}
\subsubsection{简介}
\red{CSS的牛X之处在哪？}答：\yellow{层叠}样式表
\begin{enumerate}
    \item 层叠指什么？
          \begin{itemize}
              \item \orange{样式层叠}
              \item 可以多次对同一选择器进行样式声明
              \item \orange{选择器层叠}
              \item 可以用不同选择器对同一个元素进行样式声明
              \item \orange{文件层叠}
              \item 可以用多个文件进行层叠
              \item \orange{这些特性使得CSS极度灵魂}
              \item 这也为CSS后来被吐槽留下了隐患
          \end{itemize}
    \item 如何知道哪些浏览器支持哪些特性？
          \begin{itemize}
              \item 使用\yellow{caniuse.com}
          \end{itemize}
\end{enumerate}
\subsubsection{语法}
\red{CSS语法超级简单}
\begin{enumerate}
    \item \orange{语法一：样式语法}
          \begin{lstlisting} 
            选择器 {
                属性名: 属性值；
                /* 注释 */
            }
        \end{lstlisting}
    \item \orange{语法二：at语法}
          \begin{itemize}
              \item 使用\yellow{caniuse.com}
          \end{itemize}
\end{enumerate}
\subsubsection{Border调试法}
\red{类似log调试法，很重要}
\begin{lstlisting} 
border: 1px solid red;
\end{lstlisting}
\subsubsection{文档流}
\red{Normal Flow}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/normalflow.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{文档流动方向} %最终文档中希望显示的图片标题
\end{figure}
\begin{enumerate}
    \item \red{文档流}的基本概念
          \begin{itemize}
              \item \orange{流动方向}
                    \begin{itemize}
                        \item inline元素从左到右，到达最右边才会换行
                        \item block元素从上到下，每一个都另起一行
                        \item inline-block也是从左到右
                    \end{itemize}
              \item \orange{宽度}
                    \begin{itemize}
                        \item inline宽度为内部inline元素的和，不能用width指定
                        \item block默认自动计算宽度，可用width指定
                        \item inline-block结合前两者特点，可用width
                    \end{itemize}
              \item \orange{高度}
                    \begin{itemize}
                        \item inline高度由line-height间接确定，跟height无关
                        \item block高度由文档流元素决定，可以设height
                        \item inline-block跟block类似，可以设置height
                    \end{itemize}
          \end{itemize}
    \item overflow 溢出
          \begin{itemize}
              \item \orange{当内容大于容器}
                    \begin{itemize}
                        \item 等内容的宽度或高度大于容器，会溢出
                        \item 可用overflow来设置是否显示滚动条
                        \item auto是灵活设置
                        \item scroll是永远显示
                        \item hidden是直接隐藏溢出部分
                        \item visible是直接显示溢出部分
                        \item overflow可以分为overflow-x和overflow-y
                    \end{itemize}
          \end{itemize}
    \item 脱离文档流
          \begin{itemize}
              \item \orange{回忆一下}
                    \begin{itemize}
                        \item block高度由内部文档流元素决定，可以设height
                        \item 这句话的意识是不是说，有些元素可以不在文档流中？
                    \end{itemize}
              \item \orange{有些元素可不在文档流}
                    \begin{itemize}
                        \item 原因是block高度由内部文档流元素决定，可以设height
                    \end{itemize}
              \item \orange{以下元素脱离文档流}
                    \begin{itemize}
                        \item float
                        \item position:absolute/fixed
                    \end{itemize}
              \item \orange{不用以上属性就不脱离文档流}
          \end{itemize}
\end{enumerate}
\subsubsection{盒模型}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/box.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{content-box和border-box} %最终文档中希望显示的图片标题
\end{figure}
\begin{enumerate}
    \item \orange{两种}
          \begin{itemize}
              \item content-box内容盒 - 内容就是盒子的边界
              \item border-box边框盒 - 边框才是盒子的边界
          \end{itemize}
    \item \orange{公式}
          \begin{itemize}
              \item content-box width = 内容宽度
              \item border-box width = 内容宽度 + padding + border
          \end{itemize}
    \item \orange{哪个好用？}
          \begin{itemize}
              \item border-box好用
              \item 因为可以同时指定padding, width, border
          \end{itemize}
\end{enumerate}
\subsubsection{margin合并}
\begin{enumerate}
    \item \orange{哪些情况会合并}
          \begin{itemize}
              \item 父子margin合并
              \item 兄弟margin合并
          \end{itemize}
    \item \orange{如何阻止合并}
          \begin{itemize}
              \item 父子合并用padding/border挡住
              \item 父子合并用overflow:hidden挡住
              \item 父子合并用display:flex
              \item 兄弟合并是符合预期的
              \item 兄弟合并可以用inline-block消除
              \item css属性逐年增多，每年都有新的，死记就完事了
          \end{itemize}
\end{enumerate}
\subsubsection{基本单位}
\begin{enumerate}
    \item \orange{长度单位}
          \begin{itemize}
              \item px像素
              \item em相对于自身font-size的倍数
              \item 百分数
              \item 整数
              \item rem:等你把em滚瓜烂熟了再问rem
              \item vw和vh
          \end{itemize}
    \item \orange{颜色}
          \begin{itemize}
              \item 十六进制\#FF6600或者\#F60
              \item RGBA颜色rgb(0,0,0)或者rgba(0,0,0,1)
              \item hsl颜色hsl(360,100$\%$, 100$\%$)
          \end{itemize}
\end{enumerate}
\subsubsection{练手项目}
\red{彩虹demo}
\pl
\subsection{布局}
\subsubsection{布局分类}
\begin{enumerate}
    \item 两种
          \begin{itemize}
              \item 固定宽度布局，一般宽度为960/1000/1024px
              \item 不固定宽度布局，主要靠文档流的原来布局
          \end{itemize}
    \item 回顾
          \begin{itemize}
              \item 文档流本来就是自适应的，不需要加额外的样式
          \end{itemize}
    \item 响应式布局
          \begin{itemize}
              \item PC上固定宽度，手机上不固定宽度
              \item 也就是一种混合布局
          \end{itemize}
\end{enumerate}
\subsubsection{两种布局思路}
\begin{enumerate}
    \item 从大到小
          \begin{itemize}
              \item 先定下大局
              \item 然后完善每个部分的小布局
          \end{itemize}
    \item 从小到大
          \begin{itemize}
              \item 先完成小布局
              \item 然后组合成大布局
          \end{itemize}
    \item 两种均可
          \begin{itemize}
              \item 新人推荐第二种，因为小的简单
              \item 老手一般用第一种，因为熟练有大局观
          \end{itemize}
\end{enumerate}
\subsubsection{float布局}
一图流(图片以后贴出)
\begin{enumerate}
    \item float布局
          \begin{itemize}
              \item 子元素加上float:left和width
              \item \red{在父元素上加.clearfix}
          \end{itemize}
    \item float布局经验
          \begin{itemize}
              \item 留一些空间或者最后一个不设width
              \item 不需要做响应式，因为手机上没有IE，而这个布局是专门为IE准备的
              \item 解决IE6/7存在的双倍 margin bug如下
              \item 一是将错就错，针对IE6/7把margin减半
              \item 二是神来一笔，再加一个display:inline-block
          \end{itemize}
\end{enumerate}
\paragraph{float布局实践}
\begin{enumerate}
    \item 不同布局
          \begin{itemize}
              \item 用float做两栏布局(如顶部条)
              \item 用float做三栏布局(如内容区)
              \item 用float做四栏布局(如导航)
              \item 用float做平均布局(如产品展示区)
              \item
          \end{itemize}
    \item 实践经验
          \begin{itemize}
              \item 加上头尾，即可满足所有PC页面需求
              \item 手机页面傻子采用float
              \item float要程序员自己计算宽度，不灵活
              \item float用来应付IE足矣
          \end{itemize}
\end{enumerate}
\subsubsection{Flex布局}
\begin{enumerate}
    \item 重点
          \begin{itemize}
              \item display：flex
              \item flex-direction：row/column
              \item flex-wrap:wrap
              \item just-content:center/space-between
              \item align-item:center
          \end{itemize}
    \item 颜色
          \begin{itemize}
              \item 十六进制\#FF6600或者\#F60
              \item RGBA颜色rgb(0,0,0)或者rgba(0,0,0,1)
              \item hsl颜色hsl(360,100$\%$, 100$\%$)
          \end{itemize}
    \item 实践
          \begin{itemize}
              \item 用flex做两栏布局
              \item 用flex做三栏布局
              \item 用flex做四栏布局
              \item 用flex做平均布局
              \item 用flex组合使用，做更复杂的布局
              \item
          \end{itemize}
    \item 经验
          \begin{itemize}
              \item 永远不要把width和height写死，除非特殊说明
              \item 用min-width/max-width/min-height/max-height
              \item flex可以基本满足所有需求
              \item flex和margin-xxx：auto配合有意外的效果
          \end{itemize}
    \item 什么是写死
          \begin{itemize}
              \item width:100px
          \end{itemize}
    \item 不写死
          \begin{itemize}
              \item width:50\%
              \item max-width:100px
              \item width:30vw
              \item min-width:80\%
              \item 特点：不使用px，或者加min max前缀
          \end{itemize}
\end{enumerate}
\subsubsection{Grid布局}
\red{二维布局用Grid，一维布局用Flex}
\paragraph{语法}
\paragraph{例子和语法}
\subsection{定位}
\red{布局与定位的区别是：布局是屏幕平面上的，定位是垂直于屏幕的}
\subsubsection{一个div的分层}
\subsubsection{positon的五个取值}
\subsubsection{层叠上下文}
\subsection{动画}
\subsubsection{动画的原理}
\subsubsection{浏览器渲染的原理}
\paragraph{浏览器渲染过程}
\begin{enumerate}
    \item 根据HTML构建HTML树(DOM)
    \item 根据CSS构建CSS树(CSSOM)
    \item 将两颗树合并成一颗渲染树(render tree)
    \item Layout布局(文档流，盒模型，计算大小和位置)
    \item Paint绘制(把边框颜色，文字颜色，阴影等画出来)
    \item Compose合成(根据层叠关系展示画面)
\end{enumerate}
\paragraph{三棵树}
图片以后放
\paragraph{如何更新样式}
\red{一般我们采用JS来更新样式}
\begin{enumerate}
    \item 比如div.style.background='red'
    \item 比如div.style.display='none'
    \item 比如div.classList.add('red')
    \item 比如div.remove()直接删掉节点
\end{enumerate}
\paragraph{三种更新方式}
\begin{enumerate}
    \item JS/CSS > 样式 > 布局 > 绘制 > 合成
    \item JS/CSS > 样式 > 绘制 > 合成
    \item JS/CSS > 样式 > 合成
\end{enumerate}
\paragraph{三种更新方式区别}
\begin{enumerate}
    \item 第一种，全走
          \begin{itemize}
              \item div.remove()会触发当前消失，其他元素relayout
              \item
          \end{itemize}
    \item 第二种，跳过layout
          \begin{itemize}
              \item 改变背景颜色，直接repaint+composite
              \item
          \end{itemize}
    \item 第三种，跳过layout和paint
          \begin{itemize}
              \item 改变transform，只需composite
              \item 注意必须全屏查看效果，在iframe里看有问题
              \item
          \end{itemize}
\end{enumerate}
\subsubsection{CSS动画优化}
\paragraph{JS优化}
\begin{enumerate}
    \item 使用requestAnimationFrame代替setTimeout或setInterval
\end{enumerate}
\paragraph{JS优化}
\begin{enumerate}
    \item 使用will-change或translate
\end{enumerate}
\paragraph{参考文章}
\subsubsection{transition}
\red{位移translate\quad  缩放scale\quad 旋转rotate\quad  倾斜skew}
\paragraph{经验}
\begin{enumerate}
    \item 一般都不需要配合transition过度
    \item inline元素不支持transform，需要先变成block
\end{enumerate}
\paragraph{translate}
\begin{enumerate}
    \item 常用写法
          \begin{itemize}
              \item translateX(<length-percentage>)
              \item translateY(<length-percentage>)
              \item translate(<length-percentage>, <length-percentage>?)
              \item translateZ(<length>)且父容器perspective
              \item translate3d(x,y,z)
              \item 演示
          \end{itemize}
    \item 经验
          \begin{itemize}
              \item 看懂MDN语法示例
              \item translate(-50\%, -50\%)可做绝对定位元素的居中
          \end{itemize}
\end{enumerate}
\paragraph{scale}
\begin{enumerate}
    \item 常用写法
          \begin{itemize}
              \item scaleX(<number>)
              \item scaleX(<number>)
              \item scaleX(<number>, <number>?)
              \item 演示
          \end{itemize}
    \item 经验
          \begin{itemize}
              \item 用的少
          \end{itemize}
\end{enumerate}
\paragraph{rotate}
\begin{enumerate}
    \item 常用写法
          \begin{itemize}
              \item rotate([<angle>|<zero>])
              \item rotateZ([<angle>|<zero>])
              \item rotateX([<angle>|<zero>])
              \item rotateY([<angle>|<zero>])
              \item rotate3d太复杂
              \item 演示
          \end{itemize}
    \item 经验
          \begin{itemize}
              \item 一般用于360度选择制作loading
              \item 用到的时候查rotate MDN文档
          \end{itemize}
\end{enumerate}
\paragraph{skew}
\begin{enumerate}
    \item 常用写法
          \begin{itemize}
              \item skewX([<angle>|<zero>])
              \item skewY([<angle>|<zero>])
              \item skew([<angle>|<zero>],[<angle>|<zero>]?)
              \item 演示
          \end{itemize}
    \item 经验
          \begin{itemize}
              \item 用的较少
              \item 用到的时候查skew MDN文档
          \end{itemize}
\end{enumerate}
\paragraph{transform多重效果}
\begin{enumerate}
    \item 组合使用
          \begin{itemize}
              \item transform:scale(0.5) translate(-100\%, -100\%);
              \item transform:none;取消所有
          \end{itemize}
\end{enumerate}
\paragraph{参考文章}
\subsubsection{transition过渡}
\red{作用是补充中间帧}
\subsubsection{红心实践}
\red{css需要想象力}
\section{HTTP}
\red{Hyper Text Transfer Protocol}
\subsection{URL}
\red{Uniform Resource Locator}
\pl
\red{协议+域名或IP+端口号+路径+查询字符串+锚点}
\subsubsection{IP}
\red{Internet Protocal}
\begin{enumerate}
    \item 约定了两件事
          \begin{itemize}
              \item 如何定位一台设备
              \item 如何封装数据报文，以跟其他设备交流
          \end{itemize}
    \item 外网IP
          \begin{itemize}
              \item 从电信租用带宽，一年一千多。
              \item 买了路由器，然后用电脑和手机分别连接路由器广播出来的无线WIFI。
              \item 路由器连上电信服务器，路由器有一个外围IP，这是你互联网中的地址。
              \item 重启路由器可能会被重新分配外围IP，也就是路由器没有固定的外网IP。
              \item 连接路由器的手机和电脑是内网IP。
          \end{itemize}
    \item 内网IP
          \begin{itemize}
              \item 路由器会在家里创建一个内网，内网设备使用内网IP，一般是192.169.xxx.xxx。
              \item 一般路由器会给自己分配一个好记的内网IP，如192.168.1.1。
              \item 然后路由器会给每一个内网中的设备分配不同的内网IP。
              \item  如电脑是192.168.1.2，手机是192.168.1.3。
          \end{itemize}
    \item 路由器的功能
          \begin{itemize}
              \item 现在路由器会有两个IP，一个外网IP和一个内网IP。
              \item 内网的设备可以互相访问，但是不能直接访问外网。
              \item 内网设备想要访问外围，就必须经过路由器中转。
              \item 外网中的设备可以互相访问，但是无法访问你的内网。
              \item 外网设备想要把内容送到内网，也必须通过路由器。
              \item 也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器。
              \item 所以路由器有时候也被叫做网关。
          \end{itemize}
    \item 几个特殊的IP
          \begin{itemize}
              \item 127.0.0.1表示自己。
              \item localhost通过hosts指定为自己。
              \item 0.0.0.0不表示任何设备。
          \end{itemize}
\end{enumerate}
\subsubsection{端口}
\red{一台机器可以提供很多服务，每个服务一个号码，这个号码就叫端口号port}
\begin{enumerate}
    \item 一个比喻
          \begin{itemize}
              \item 麦当劳提供两个窗口，一号快餐，二号咖啡。
              \item 你去快餐窗口点咖啡会被拒绝，让你去两一个窗口。
              \item 你去咖啡窗口点快餐结果一样。
          \end{itemize}
    \item 一台机器可以提供不同服务
          \begin{itemize}
              \item 要提供HTTP服务最好使用80端口。
              \item 要提供HTTPS服务最好使用443端口。
              \item 要提供FTP服务最好使用21端口。
              \item 一共有65535个端口(基本够用)。
          \end{itemize}
    \item 端口使用规则
          \begin{itemize}
              \item 0到1023(2的10次方减1)号端口是留给系统使用的。
              \item 你只有拥有了管理员权限后，才能使用这1024个端口。
              \item 其他端口可以给普通用户使用。
              \item 比如http-server默认使用8080端口。
              \item 一个端口如果被占用，你就只能换一个端口。
          \end{itemize}
\end{enumerate}
\subsubsection{域名}
\begin{enumerate}
    \item 域名就是IP的别称
          \begin{itemize}
              \item baidu.com对应的什么IP --> ping baidu.com
              \item qq.com对应的什么IP --> ping qq.com
              \item 一个域名可以对应不同IP。
              \item 这个叫做均衡负载，防止一台机器扛不住。
              \item 一个IP可以对应不同域名。
              \item 这个叫做共享主机，穷开发者会这么做。
          \end{itemize}
    \item 域名和IP是怎么对应起来的
          \begin{itemize}
              \item 通过DNS
          \end{itemize}
    \item 当你输入qq.com的过程
          \begin{itemize}
              \item 你的Chrome浏览器会向电信提供的DNS服务器询问qq.com对应什么IP。
              \item 电信会回答一个IP(具体过程很发杂，不研究)。
              \item 然后Chrome才会向对应IP的80/443端口发送请求。
              \item 请求内容是查看qq.com的首页。
          \end{itemize}
    \item 为什么是80或443端口
          \begin{itemize}
              \item 服务器默认用80提供http服务。
              \item 服务器默认用443提供https服务。
              \item 可以在开发者工具看到具体的端口。
          \end{itemize}
    \item 题外话
          \begin{itemize}
              \item www.caosiyuan.com和caosiyuan.com不是同一域名。
              \item comn是顶级域名。
              \item caosiyuan.com是二级域名(俗称一级域名)。
              \item www.caosiyuan.com是三级域名(俗称二级)。
              \item 他们是父子关系
              \item 比如github.io把子域名xx.github.io免费给你使用
              \item 但www.caosiyuan.com和caosiyuan.com可以不是同一家公司，也可以是。
              \item www非常多余
          \end{itemize}
    \item 如何请求不同的页面
          \begin{itemize}
              \item 路径可以做到
              \item \url{https://developer.mozilla.org/zh-CN/docs/Web/HTML}
              \item \url{https://developer.mozilla.org/zh-CN/docs/Web/CSS}
              \item 使用chrome开发者工具Network面板看区别。
              \item 有点类似爬虫找规律。
          \end{itemize}
    \item 同一个页面，不同内容
          \begin{itemize}
              \item 查询参数可以做到
              \item \url{http://www.baidu.com/s?wd=hi}
              \item \url{http://www.baidu.com/s?wd=hello}
          \end{itemize}
    \item 同一个页面，不同位置
          \begin{itemize}
              \item 锚点可以做到
              \item \url{https://developer.mozilla.org/zh-CN/docs/Web/CSS#参考书}
              \item \url{https://developer.mozilla.org/zh-CN/docs/Web/CSS#教程}
              \item 注意，锚点看起来有中文，但实际不支持中文。
              \item \# 参考书会变成\#\s{\%E5\%8F\dots}。
              \item 锚点是无法在Network面板看到。
              \item 锚点不会传给服务器。
          \end{itemize}
\end{enumerate}
\subsubsection{HTTP协议}
\red{基于TCP和IP两个协议，规定了请求的格式是什么，响应的格式是什么}
\begin{enumerate}
    \item 用curl可以发HTTP请求
          \begin{itemize}
              \item curl -v http://baidu.com
              \item curl -s -v -- https://www.baidu.com
          \end{itemize}
    \item 理解一下概念
          \begin{itemize}
              \item url会被curl工具重写，先请求DNS获得IP
              \item 先进行TCP连接，TCP连接成功后，开始发送HTTP请求
              \item 请求内容看一眼
              \item 响应内容看一眼
              \item 响应结束后，关闭TCP连接(看不出来)
              \item 真正结束
          \end{itemize}
\end{enumerate}
\subsection{请求响应和NodeJS Sever}



\section{JS}
\subsection{概览}
\red{JS需要一点逻辑能力，数学学的好不用担心，因为比数学简单太多了。}
\subsubsection{硬要求}
\begin{enumerate}
    \item 足够的代码量
          \begin{itemize}
              \item 达到1000行 -->  新手
              \item 达到10000行 --> 熟手
              \item 达到50000行 --> 专业选手
              \item 只能靠时间积累，人生就是奋斗，最快一年就可达到。
          \end{itemize}
    \item 如何统计自己的代码行数
          \begin{itemize}
              \item 安装 yarn global add cloc
              \item 在项目文件下使用 cloc --vcs=git.
              \item 注意把仓库里node\_modules等不想关内容写入.gitignore
          \end{itemize}
    \item 了解最够多的概念，不仅会写，还要会说
          \begin{itemize}
              \item 常用考点：闭包，原型，类，继承，MVC，Flux，高阶函数，前端工程化
              \item 博客总结，代码实践，多多积累。
          \end{itemize}
    \item 有足够的踩坑经验
          \begin{itemize}
              \item 把该领域内所有的错误都犯完的人，就是专家。
              \item 多做个人项目，全方位踩坑。
          \end{itemize}
\end{enumerate}
% \subsubsection{JS的历史}
% \begin{enumerate}
%     \item JavaScript的诞生
%           \begin{itemize}
%               \item 布兰登生平自行了解，我的总结是成为了领导后千万不能犯错。
%               \item 牛逼的程序员不怕辞退，很容易创业，可以干到50岁以上。
%               \item 公司要求JS的命名蹭Java的流量，现在各行各业也存在者这种营销。
%               \item 由于版权问题，JS又叫ECMAScript。
%               \item 布兰登十天设计了JS最初版本(不是实现)，所以JS有很多bug。
%               \item 网景被微软收购，IE6如日中天。
%               \item 2004谷歌雇佣了一些Firefox和IE的开发者。
%               \item 2016年Chrome全球份额62\%, 横空出世。
%               \item 移动市场智能手机的崛起。
%           \end{itemize}
%     \item JavaScript的兴起
%           \begin{itemize}
%               \item 2004年愚人节，谷歌发布Gmail在线网页，当时人们认为网页只能看新闻和图片。
%               \item 2005年，Jesse将谷歌用到的技术命名为AJAX，从此，前端技术正式出现。
%               \item 用历史唯物主义的观念看，正如现在很多前端概念就是过去技术的打包。
%               \item 在此之前的网页开发都是由后端和设计师完成。
%               \item 2006年，jQuery发布，是目前最长寿的JS库。
%               \item 后来的十年，jQuery大放异彩，直到IE不行了，才稍微没有那么火。
%           \end{itemize}
%     \item 中国的前端
%           \begin{itemize}
%               \item 正式出现时间是2010年左右，中国才有专门的前端岗位。
%               \item 可以用百度指数关键词搜索趋势。
%               \item 早期的前端是一些自学前端的后端程序员，他们把Java思想带入JS
%               \item 因此面向对象成了JS的主流思想。
%               \item 行业还是很缺前端。
%           \end{itemize}
%     \item JavaScript的爆发
%           \begin{itemize}
%               \item Chrome的JS引擎叫做V8, V8原本是跑车引擎的叫法， 快如闪电。
%               \item 2009年，Ryon基于V8创建了Node.js。
%               \item 2010年，Isaac基于Node.js写出了npm。
%               \item 前端工程师可以在浏览器之外执行JS了，Node.js快速风靡。
%               \item 同年，TJ受Sinatra启发，发布了Express.js。
%               \item 至此，前端工程师可以愉快的写后端应用了。
%               \item 至此，爆发了很多技术了，gulp，grunt，yeoman，requireJs，webpack等。
%               \item JS是历史的选择，一开始是玩具，但JS走对了风口，所以活到了最后。
%               \item 总结：类似考研政治，历史人物可以影响事物的进程，但决定不了历史的发展的方向。
%           \end{itemize}
% \end{enumerate}
\subsection{内存图与JS世界}
\subsubsection{操作系统常识}
\red{一切都运行在内存里}
\begin{enumerate}
    \item 开机
          \begin{itemize}
              \item 操作系统在C盘里(macOS的在根目录下多个目录里)
              \item 当按下开机键，主板通电，开始读取固件
              \item 固件就是固定在主板上的存储设备，里面有开机程序
              \item 开机程序会将文件里的操作系统加载到内存中运行
          \end{itemize}
    \item 操作系统(以Linux为例)
          \begin{itemize}
              \item 首先加载操作系统内核
              \item 然后启动初始化进程，编号为1，每个进程都有编号
              \item 启动系统服务：文件，安全，联网
              \item 等待用户登录：输入密码登录/ssh登录
              \item 登录后，运行shell，用户就可以和操作系统对话了
              \item bash是一种shell，图形化界面可认为是一种shell
          \end{itemize}
    \item 打开浏览器(chrome.exe)
          \begin{itemize}
              \item 你双击Chrome图标，就会运行chrome.exe文件
              \item 开启Chrome进程，作为主进程
              \item 主进程会开启一些辅助进程，如网络服务，GPU加速
              \item 你每新建一个网页，就有可能会开启一个子进程
          \end{itemize}
    \item 浏览器的功能
          \begin{itemize}
              \item 发起请求，下载HTML，解析HTML，下载CSS，解析CSS
              \item 渲染界面，下载JS，解析JS，执行JS等
              \item 功能模块：用户界面，渲染引擎，JS引擎，存储等
              \item 以上功能模块一般各处于不同的线程(比进程更小)
              \item 如果进程是车间，那么线程就是车间里的流水线
          \end{itemize}
    \item JS引擎
          \begin{itemize}
              \item Chrome用的是由C++编写的V8引擎
              \item 网景用的是SpiderMonkey，后被Firefox使用
              \item Safari用的是JavaScriptCore
              \item IE用的是Chakra(JScript9)
              \item Edge用的是Chakra(JavaScript)
              \item Node.js用的是V8引擎
          \end{itemize}
    \item JS引擎的功能
          \begin{itemize}
              \item 编译：把JS代码翻译为机器能执行的字节码或机器码
              \item 优化：改写代码，使其更高效
              \item 执行：执行上面的字节码或者机器码
              \item 垃圾回收：把JS用完的内存回收，方便之后再次使用
          \end{itemize}
    \item 执行JS代码的准备工作
          \begin{itemize}
              \item 浏览器提供API：window/document/setTimeout
              \item 没错，上面东西都不是JS自身具备的功能
              \item 我们将这些功能称为运行环境runtime env
              \item 一旦把JS放进页面，就开始执行JS
              \item JS代码在内存里运行，看下部分内存图
          \end{itemize}
\end{enumerate}
\subsubsection{内存图}
\red{要求会画内存图}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering %图片居中
    \includegraphics[width=0.7\textwidth]{image/memory.png} %插入图片，[]中设置图片大小，{}中是图片文件名
    \caption{瓜分内存图} %最终文档中希望显示的图片标题
    \label{瓜分内存图} %用于文内引用的标签
\end{figure}
\begin{enumerate}
    \item 红色区域的作用
          \begin{itemize}
              \item 红色专门用来存放数据，我们目前只研究该区域
              \item 红色区域并不存变量名，变量名在\red{不知什么区}
              \item 每种浏览器的分配规则并不一样
              \item 还有调用栈，任务队列尚未画出
          \end{itemize}
    \item Stack和Heap
          \begin{itemize}
              \item 红色区域分为Stack栈和Heap堆
              \item 栈和堆需要用到数据结构知识
              \item Stack区特点：每个数据顺序存放
              \item Heap区特点：每个数据随机存放
          \end{itemize}
    \item js代码在Heap和Stack区的执行过程
          \begin{lstlisting} 
        var a = 1
        var b = a 
        var person = {name: 'syuancao', hobby: 'coding'}
        var person2 = person
      \end{lstlisting}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/StackAndHeap.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{js代码在Heap和Stack区执行的内存图} %最终文档中希望显示的图片标题
              \label{js内存图} %用于文内引用的标签
          \end{figure}
    \item 规律
          \begin{itemize}
              \item 数据分两种：非对象和对象
              \item 非对象都存在Stack \red{(数字，字符串，布尔不是对象)}
              \item 对象都存在Heap \red{(数组是对象，函数是对象)}
              \item =号总是会把右边的东西复制到左边 \red{(不存在什么传值和传址，是直接拷贝，图中箭头指向是虚的)}
              \item 很多书上会让你区分值和地址，只有不会画内存图的人才需要做这件事
          \end{itemize}
    \item 对象被篡改，结合内存图很好分析
          \begin{lstlisting} 
        var person = {name:'caosiyuan'}
        var person2 = person
        person2.name = 'syuancao'
        console.log(person.name) // syuancao
      \end{lstlisting}
\end{enumerate}
\subsubsection{JS的世界是怎样的}
\red{神说要有光，就有了光，JS开发者说要有window，就有了window(浏览器提供)}
\begin{enumerate}
    \item JS世界还需要什么
          \begin{itemize}
              \item 要有console，并且挂到window上
              \item 要有document，并且挂到window上
              \item 要有对象，于是就有了Object，并且挂到window上
              \item var person = \{\}等价与 var person = new Object()
              \item 要有数组(一种特殊的对象)，于是有了Array，并且挂到window上
              \item var a = [1, 2, 3]等价于 var a = new Array(1, 2, 3)
              \item 要有函数(一种特殊的对象)，于是有了Function，并且挂到window上
              \item function f()\{\}等价于 var f = new Function()
          \end{itemize}
    \item 题外话
          \begin{itemize}
              \item 为什么有 var a = []，还要提供var a = new Array()呢
              \item 因为后者是正规写法，但是没人用，前者不正规，但是好用
              \item 为什么有function f()\{\}，还要提供var f = new Function写法呢
              \item 原因同上
          \end{itemize}
    \item 把window用内存图画出来
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/window.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{window内存图} %最终文档中希望显示的图片标题
              \label{window内存图} %用于文内引用的标签
          \end{figure}
    \item 更简单的画法
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/simplewindow.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{更简单的window内存图} %最终文档中希望显示的图片标题
              \label{更简单的window内存图} %用于文内引用的标签
          \end{figure}
          \begin{itemize}
              \item 可以用console.dir(window.Array)看属性
              \item 如果第一个字母是大写比如Object，Array，那么会就有prototype属性
          \end{itemize}
    \item 细节
          \begin{itemize}
              \item window变量和window对象是两个东西
              \item window变量是一个容器，存放window对象的地址
              \item window对象是Heap里的一坨数据
              \item 不信的话，可以让var x = window，那么这个x就指向window对象，window变量就可以去死了
              \item 但这样的代码会弄晕新手，所以不要这样写
              \item 但是jQuery就是这样挂到window上的函数，window.jQuery=function()\{\}
              \item 但是jQuery我们平时用\$， 用\$去调用，var \$ = jQuery，\$()
              \item 同理，console(属性)和console对象不是同一个东西
              \item Object和Object函数对象不是同一个东西
              \item 前者是内存地址，后者是内存对应的一坨数据也就是一坨内存
          \end{itemize}
\end{enumerate}
\subsubsection{原型链}
\red{是JS里最重要的，也是新手最难懂的之一(注：JS有三个最难懂的，分别是this，原型，AJAX)}
\begin{enumerate}
    \item 内存图里的prototype是干什么用的
          \begin{itemize}
              \item 可以打印出来看看，console.dir(window.Object.prototype)，window可以省略
              \item 只是看起来是一坨无用函数
          \end{itemize}
    \item var obj=\{\} obj.toString()为什么不报错？为什么可以运行？
          \begin{itemize}
              \item obj有一个隐藏属性
              \item 隐藏属性存储了Object.prototype对象的地址
              \item obj.toString()发现obj上没有toString
              \item 就去隐藏属性对应的对象里面找
              \item 于是就找到了Object.prototype.toString里面的toString
              \item 也就是obj.toString === window.prototype.toString
          \end{itemize}
    \item 类似的 var arr=[] arr.join('-')为什么不报错？为什么可以运行？
          \begin{itemize}
              \item arr有一个隐藏属性
              \item 隐藏属性存储了Array.prototype对象的地址
              \item arr.join()发现arr上没有join
              \item 就去隐藏属性对应的对象里面找
              \item 于是就找到了Array.prototype.join里面的join
              \item 也就是Array.prototype.join === window.prototype.join
          \end{itemize}
    \item JS的光
          \begin{itemize}
              \item 下面一张图可以解释上面的问题
                    \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
                        \centering %图片居中
                        \includegraphics[width=0.7\textwidth]{image/thelightOfJs.png} %插入图片，[]中设置图片大小，{}中是图片文件名
                        \caption{JS的光} %最终文档中希望显示的图片标题
                        \label{js的光} %用于文内引用的标签JS
                    \end{figure}
          \end{itemize}
    \item var obj2=\{\} obj2.toString() obj和obj2有什么联系
          \begin{itemize}
              \item 相同点:都调用.toString
              \item 不同点：地址不同obj!==obj2, 可以拥有不同的属性
              \item xxx.prototype存储了xxx对象的共同属性，这就是原型
          \end{itemize}
    \item 原型的好处
          \begin{itemize}
              \item 如果没有原型，声明一个对象
                    \begin{lstlisting} 
                    var obj = {
                        toString: window.Object.prototype.toString,
                        hasOwnPropertyof: window.Object......
                    }
                    obj.toString() 
                    var obj2 = {
                        toString: window.Object.prototype.toString,
                        hasOwnPropertyof: window.Object......
                    }
                    obj2.toString() 
      \end{lstlisting}
              \item 你是不是想累死自己
              \item 原型让你无需重复声明共有属性，省代码，省内存
          \end{itemize}
    \item 关于隐藏属性\_proto\_
          \begin{itemize}
              \item 每个对象都有一个隐藏属性，用来保存其原型的地址，这个隐藏属性的名字叫做\_proto\_
              \item 大写的不要关心隐藏属性，这涉及js哲学问题不用关心，关心小写的隐藏属性
              \item 如果没有隐藏属性，obj就不知道共有属性在哪，就没把法调用toString等
          \end{itemize}
    \item prototype和\_proto\_的区别是什么
          \begin{itemize}
              \item 都存着原型的地址，即相同的地址
              \item 只不过prototype挂在函数上，通常是大写的(Array, Object, Function)上面
              \item \_proto\_挂在每个新生成的对象上，也就是小写的(var a = \{\}, var b = [])上面
          \end{itemize}
    \item 犀利的提问
          \begin{itemize}
              \item 类似之前提过篡改对象的例子
                    \begin{lstlisting} 
                        var obj = {}
                        var obj2 = {}
                        obj.toString === obj2.toString //输出为true
                        obj.toString = 'fuck' // 输出为"fuck"
                        obj.toString //也等于 'fuck'吗？
              \end{lstlisting}
              \item 不废话一图解决问题
                    \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
                        \centering %图片居中
                        \includegraphics[width=0.7\textwidth]{image/objtoString.png} %插入图片，[]中设置图片大小，{}中是图片文件名
                        \caption{toString篡改} %最终文档中希望显示的图片标题
                        \label{toString篡改} %用于文内引用的标签
                    \end{figure}
              \item 原因解释
                    \begin{itemize}
                        \item 这个和之前的不一样，这里toString是隐藏属性
                        \item 结合上图相当于写了两层
                        \item 所以一层是可以篡改的，两层就不可以
                    \end{itemize}
          \end{itemize}
\end{enumerate}
\subsection{Canvas实践--画图板}
\red{\href{https://github.com/syuancao/FrontNotePractice/tree/master/JS/0-Canvas}{项目地址} }
\pl
\red{\href{https://syuancao.github.io/FrontNotePractice/JS/0-Canvas/index.html}{预览效果} }
\subsection{JS语法}
\red{es6是最低要求}
% \subsubsection{JS版本}
% \begin{enumerate}
%     \item 历史版本
%           \begin{itemize}
%               \item ES3，IE6支持，总体评价：垃圾
%               \item ES5，总体评价：还是垃圾
%               \item ES6，大部分浏览器支持，总体评级：一半垃圾一半好
%               \item ES2019与ES6差别不大
%           \end{itemize}
%     \item 为什么说ES6一半垃圾
%           \begin{itemize}
%               \item 因为ES不能删除以前的特性，需要兼容旧网站
%               \item 也就是说以前能运行的网站，以后都要能运行
%               \item 对比Python3你就能知道兼容的好处：稳定
%           \end{itemize}
%     \item 一门语言的价值
%           \begin{itemize}
%               \item 是由其产生的价值决定
%               \item JS是世界上使用最广的语言
%               \item JS是门槛极低的语言(只要你不学糟粕)
%               \item JS是一门能产生价值的语言(虽然不美)
%               \item 它的优秀之处并非原创，它的原创之处并不优秀 -- 来自JS之父的评价
%           \end{itemize}
% \end{enumerate}
% \subsubsection{语法}
% \begin{enumerate}
%     \item 表达式
%           \begin{itemize}
%               \item 1+2表达式的值为3
%               \item add(1,2)表达式的值为函数的返回值
%               \item console.log表达式的值为函数本身
%               \item console.log(3)表达式的值为多少？(undefined)
%           \end{itemize}
%     \item 语句
%           \begin{itemize}
%               \item var a = 1是一个和语句
%           \end{itemize}
%     \item 二者的区别
%           \begin{itemize}
%               \item 表达式一般都有值，语句可能有也可能没有
%               \item 语句一般会改变环境(声明，赋值)
%               \item 上面两句话并不是绝对的
%           \end{itemize}
%     \item 大小写敏感
%           \begin{itemize}
%               \item var a和var A是不同的
%               \item object和Object是不同的
%               \item function和Function是不同的
%               \item 具体含义后面说
%           \end{itemize}
%     \item 空格
%           \begin{itemize}
%               \item 大部分空格没有实际意义
%               \item var a = 1和var a=1没有区别
%               \item 加回车大部分时候也不影响
%               \item 只有一个地方不能加回车，那就是return后面
%           \end{itemize}
%     \item 标识符的规则
%           \begin{itemize}
%               \item 第一个字符，可以是Unicode字母或\$或\-或中字
%               \item 后面的字符，除了上所说，还可以有数字
%               \item 变量名是标识符
%           \end{itemize}
%     \item 区块block
%           \begin{itemize}
%               \item 把代码包在一起
%               \item 常常与if/for/while合用
%           \end{itemize}
%     \item if语句
%           \begin{itemize}
%               \item if(表达式){语句1}else{语句2}
%               \item \{\}在语句只有一句的时候可以省略，但不建议这么做
%           \end{itemize}
%     \item if语句变态情况
%           \begin{itemize}
%               \item 表达式里可以非常变态，如 a = 1
%               \item 语句1里可以非常变态，如嵌套if else
%               \item 语句2里可以非常变态，如嵌套if else
%               \item 缩进也可以很变态，如面试常常下套
%                     \begin{lstlisting} 
%                         a = 1
%                         if (a === 2) 
%                             console.log('a')
%                             console.log('a等于2')
%                     \end{lstlisting}
%           \end{itemize}
%     \item while循环
%           \begin{itemize}
%               \item while(表达式){语句}
%               \item 当表达式为真，执行语句，执行完再判断表达式真假
%               \item 当表达式为假，执行后面的语句
%               \item do ... while可以做用户输入判定
%           \end{itemize}
%     \item for循环
%           \begin{itemize}
%               \item for循环是while的方便写法
%               \item for(语句1;表达式2;语句3) {循环体}
%               \item 不多说了，和C语言一样
%           \end{itemize}
%     \item label语句
%           \begin{itemize}
%               \item 语法
%                     \begin{lstlisting} 
%                 foo: {
%                     console.log(1);
%                     break foo;
%                     console.log('本行不会输出);
%                 }
%                 console.log(2);

%                 foo: 1; 

%                 {
%                     foo: 1;
%                 }
%             \end{lstlisting}
%               \item 面试:下面的东西是什么？下面是代码块，是label，不是对象
%                     \begin{lstlisting} 
%                         {
%                             foo: 1
%                         }
%             \end{lstlisting}
%           \end{itemize}
% \end{enumerate}
\subsubsection{JS数据}
\begin{enumerate}
    \item 7种数据类型(大小写无所谓)
          \begin{itemize}
              \item 数字number
              \item 字符串string
              \item 布尔bool
              \item 符号symbol
              \item 空undefined
              \item 空null
              \item 对象object
              \item 总结：四基两空一对象
          \end{itemize}
    \item 以下不是数据类型
          \begin{itemize}
              \item 数组，函数，日期
              \item 它们都属于object
          \end{itemize}
    \item 5个falsy值
          \begin{itemize}
              \item falsy就是相当于false但又不是false值
              \item 分别是undefined null 0 NaN ''
              \item '' '  ' 即空字符串和空格字符串不是一个玩意
          \end{itemize}
    \item undefined和null的区别
          \begin{itemize}
              \item 这是js的垃圾之处，没有本质区别
              \item 如果一个变量声明了，但没有赋值，那么默认值就是undefined而不是null
              \item 如果一个函数，没有写return，那么默认return undefined, 而不是null
              \item 前端程序员习惯上，把非对象的空值写成undefined，把对象空值写为null
              \item 仅仅是习惯而已
          \end{itemize}
    \item let声明
          \begin{itemize}
              \item 遵循块作用域，即使用范围不能超出{}
              \item 不能重复申明
              \item 可以赋值，也可以不赋值
              \item 必须先声明再使用，否则报错
              \item 全局声明的let变量，不会变成window的属性
              \item for循环配合let有奇效
          \end{itemize}
    \item 类型转换
          \begin{itemize}
              \item number => string
                    \begin{itemize}
                        \item String(n)
                        \item n + ''
                    \end{itemize}
              \item string => number
                    \begin{itemize}
                        \item Number(s)
                        \item parseInt(s)/parseFloat(s)
                        \item s - 0
                    \end{itemize}
              \item x => bool
                    \begin{itemize}
                        \item Boolean(x)
                        \item x.toString()
                    \end{itemize}
          \end{itemize}
\end{enumerate}
\subsubsection{JS对象}
\red{第七种数据类型，唯一一种复杂类型}
\begin{enumerate}
    \item 定义
          \begin{itemize}
              \item 无序的数据集合
              \item 键值对的集合
          \end{itemize}
    \item 写法

          \begin{lstlisting} 
                let obj = {'name': 'caosiyuan', 'aga': '27'}
                let obj = new Object({'name': 'caosiyuan'})
                console.log({'name': 'caosiyuan', 'age': 18})
            \end{lstlisting}

    \item 细节
          \begin{itemize}
              \item 键名是字符串，不是标识符，可以包含任意字符
              \item 引号可以省略，省略之后就只能写标识符
              \item \red{就算引号省略了，键名也还是字符串}
          \end{itemize}
    \item 变量作属性名
          \begin{itemize}
              \item 不加[]的属性名会自动变成字符串
              \item 加了[]则会当作变量求值
              \item 值如果不是字符串，则会自动变成字符串
              \item 除了字符串，symbol也能做属性名
          \end{itemize}
    \item 对象的隐藏属性
          \begin{itemize}
              \item JS中每一个对象都有一个隐藏属性
              \item 这个隐藏属性储存着其\red{共有属性组成的对象}的地址
              \item 这个\red{共有属性组成的对象}叫做原型
              \item 也就是说，隐藏属性储存着原型的地址
          \end{itemize}
    \item 删除属性
          \begin{itemize}
              \item delete obj.xxx或obj['xxx']
              \item 即可删除obj的xxx属性，请区分属性值为undefined和不含属性名
              \item 不含属性名 'xxx' in obj === false
              \item 含有属性名，但是值为undefined，'xxx' in obj \&\& obj.xxx === undefined
              \item 注意obj.xxx === undefined不能断定'xxx'是否为obj的属性
          \end{itemize}
    \item 查看所有属性(读属性)
          \begin{itemize}
              \item 查看自身所有属性Object.keys(obj)
              \item 查看自身+共有属性console.dir(obj)
              \item 或者自己依次用Object.keys打印出obj.\_proto\_
              \item obj.hasOwnPropertyof('toString')判断一个属性是自身的还是共有的
          \end{itemize}
    \item 原型
          \begin{itemize}
              \item 每个对象都有原型，原型里存着对象的共有属性
              \item 比如obj的原型就是一个对象
              \item obj.\_proto\_存着这个对象的地址
              \item 这个对象里有toString/constructor/valueOf等属性
              \item 对象的原型也是对象，所以对象的原型也有对象
              \item obj={}的原型即为所有对象的原型
              \item 这个原型包含所有对象的共有属性，是对象的根
              \item 这个原型也有原型，是null
          \end{itemize}
    \item 查看属性
          \begin{itemize}
              \item 中括号语法：obj['key']
              \item 点语法：obj.key
              \item 坑新人语法：obj[key] // 变量key值一般不为'key'
              \item 优先使用中括号语法，点语法会误导你，让你以为key不是字符串
          \end{itemize}
    \item 修改或增加属性(写属性)
          \begin{itemize}
              \item 直接赋值 obj.name = 'caosiyuan'
              \item 批量赋值 Object.assign(obj, {age: 27, gender: 'man'})
          \end{itemize}
    \item 修改或增加共有属性
          \begin{itemize}
              \item 无法通过自身修改或增加共有属性
              \item let obj = {}, obj2 = {}//共有toString
              \item obj.toString = 'xxx'只会再改obj自身属性
              \item obj.toString还是在原型上
          \end{itemize}
    \item 我偏要修改或增加原型上的属性
          \begin{itemize}
              \item obj.\_proto\_toString = 'xxx'//不推荐用\_proto\_
              \item Object.prototype.toString='xxx'
              \item 一般来说，不要修改原型，这会引起很多问题
          \end{itemize}
    \item  修改隐藏属性
          \begin{itemize}
              \item  不推荐用\_proto\_
                    \begin{lstlisting} 
                let obj = {'name': 'caosiyuan'}
                let obj2 = {'name': 'syuancao'}
                let common = {kind: 'human'}
                obj.__proto__ = commmon 
                obj2.__proto__ = common
            \end{lstlisting}

              \item 推荐使用Object.create
                    \begin{lstlisting} 
                        let obj = Object.create(common)
                        obj.name = 'caosiyuan'
                        let obj2 = Object.create(common)
                        obj2.name = 'syuancao'
                        
            \end{lstlisting}

          \end{itemize}
    \item 'name' in obj和obj.hasOwnProperty('name') 的区别
          \begin{itemize}
              \item 'name' in obj会检查对象隐藏属性即原型链
              \item obj.hasOwnProperty('name')只会检查自身，即该属性必须是对象本身的成员
          \end{itemize}
\end{enumerate}
\subsubsection{JS对象分类}
\section{算法与数据结构}
\section{JS编程接口}
\subsection{DOM编程}
\subsubsection{DOM简介}
\begin{enumerate}
    \item 网页其实是一棵树
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/tree.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{HTML树1} %最终文档中希望显示的图片标题
          \end{figure}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/tree2.png} %插入图片，[]中设置图片大小，{}中是图片文件名
              \caption{HTML树2} %最终文档中希望显示的图片标题
          \end{figure}
    \item 为什么说ES6一半垃圾
          \begin{itemize}
              \item 因为ES不能删除以前的特性，需要兼容旧网站
              \item 也就是说以前能运行的网站，以后都要能运行
              \item 对比Python3你就能知道兼容的好处：稳定
          \end{itemize}
    \item 一门语言的价值
          \begin{itemize}
              \item 是由其产生的价值决定
              \item JS是世界上使用最广的语言
              \item JS是门槛极低的语言(只要你不学糟粕)
              \item JS是一门能产生价值的语言(虽然不美)
              \item 它的优秀之处并非原创，它的原创之处并不优秀
          \end{itemize}
\end{enumerate}

% \begin{enumerate}
%     \item 网页其实是一棵树
%           \begin{itemize}
%               \item ES3，IE6支持，总体评价：垃圾
%               \item ES5，总体评价：还是垃圾
%               \item ES6，大部分浏览器支持，总体评级：一半垃圾一半好
%               \item ES2019与ES6差别不大
%           \end{itemize}
%     \item 为什么说ES6一半垃圾
%           \begin{itemize}
%               \item 因为ES不能删除以前的特性，需要兼容旧网站
%               \item 也就是说以前能运行的网站，以后都要能运行
%               \item 对比Python3你就能知道兼容的好处：稳定
%           \end{itemize}
%     \item 一门语言的价值
%           \begin{itemize}
%               \item 是由其产生的价值决定
%               \item JS是世界上使用最广的语言
%               \item JS是门槛极低的语言(只要你不学糟粕)
%               \item JS是一门能产生价值的语言(虽然不美)
%               \item 它的优秀之处并非原创，它的原创之处并不优秀
%           \end{itemize}
% \end{enumerate}
\subsubsection{获取元素的API}
\subsubsection{元素的6层原型链}
\subsubsection{创建元素的API}
\subsubsection{查看元素的API}
\subsubsection{DOM操作跨线程}
\subsection{手写DOM库}
\subsection{jQuery中的设计模式}
\subsection{DOM事件与事件委托}
\begin{enumerate}
    \item 从点击事件开始研究
          \begin{itemize}
              \item 看如下代码
                    \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
                        \centering %图片居中
                        \includegraphics[width=0.7\textwidth]{image/maopao.png} %插入图片，[]中设置图片大小，{}中是图片文件名    
                    \end{figure}
                    即.爷爷>.爸爸>.儿子, 给三个div分别添加事件监听fnYe/fnBa/fnEr
              \item 提问一：点击了谁？
                    \begin{itemize}
                        \item 点击文字，算不算点击儿子？
                        \item 点击文字，算不算点击爸爸？
                        \item 点击文字，算不算点击爷爷？
                        \item 答案：都算
                    \end{itemize}
              \item 提问二：调用顺序
                    \begin{itemize}
                        \item 点击文字，最先调用fnYe/fnBa/fnEr中的哪一个函数？
                        \item 答案：都行
                        \item IE5认为先调fnEr，网景认为先调fnYe，然后掐上了
                        \item 最后闹到了W3C
                    \end{itemize}
          \end{itemize}
    \item 和事佬W3C
          \begin{itemize}
              \item 2002年，W3C发布标准
                    \begin{itemize}
                        \item 文档名为DOM Level 2 Events Specification
                        \item 规定浏览器应该同时支持两种调用顺序
                        \item \red{首先}按\red{爷爷=>爸爸=>儿子}顺序看有没有函数监听
                        \item \red{然后}按\green{儿子=>爸爸=>爷爷}顺序看有没有函数监听
                        \item 有监听函数就调用，并提供事件信息，没有就跳过
                    \end{itemize}
              \item 术语
                    \begin{itemize}
                        \item \red{从外向内}找监听函数，叫\red{事件捕获}
                        \item \green{从内向外}找监听函数，叫\green{事件冒泡}
                    \end{itemize}
              \item 疑问：那岂不是fnYe/fnBa/fnEr都调用两次？非也！
                    \begin{itemize}
                        \item 开发者\yellow{自己选择}把fnYe放在\red{捕获阶段}还是放在冒泡阶段
                    \end{itemize}
              \item 示意图
                    \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
                        \centering %图片居中
                        \includegraphics[width=0.7\textwidth]{image/shiyitu.png} %插入图片，[]中设置图片大小，{}中是图片文件名    
                    \end{figure}
          \end{itemize}
    \item addEventListener
          \begin{itemize}
              \item 事件绑定API
                    \begin{itemize}
                        \item IE5
                              \begin{lstlisting}              
                    baba.attachEvent('onclick', fn) //冒泡
                      \end{lstlisting}
                        \item 网景
                              \begin{lstlisting}              
                    baba.addEventListener('click', fn) //捕获
                        \end{lstlisting}
                        \item W3C
                              \begin{lstlisting}              
                    baba.addEventListener('click', fn, bool) //不填支持ie，填true支持网景
                        \end{lstlisting}
                    \end{itemize}
              \item 如果bool不传或为\yellow{\underline{\href{https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy}{falsy}}}
                    \begin{itemize}
                        \item 就让fn走冒泡，即当浏览器在冒泡阶段发现baba有fn监听函数，就会调用fn，并提供事件信息
                    \end{itemize}
              \item 如果bool为true
                    \begin{itemize}
                        \item 就让fn走捕获，即当浏览器在捕获阶段发现baba有fn监听函数，就会调用fn，并提供事件信息
                    \end{itemize}
          \end{itemize}
    \item 你可以选择把fn放在哪边
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/shiyitu.png} %插入图片，[]中设置图片大小，{}中是图片文件名    
          \end{figure}
    \item \yellow{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/event-model}{代码示例}}}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/buhuo.png} %插入图片，[]中设置图片大小，{}中是图片文件名    
          \end{figure}
    \item \yellow{\underline{\href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/event-flow}{代码图解}}}
          \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
              \centering %图片居中
              \includegraphics[width=0.7\textwidth]{image/buhuotu.png} %插入图片，[]中设置图片大小，{}中是图片文件名  
              \caption{先捕获后冒泡}
          \end{figure}
    \item 小结
          \begin{itemize}
              \item 两个疑问
                    \begin{itemize}
                        \item 儿子被点击了，算不算点击老子？(算)
                        \item 那么先调用老子的函数还是先调用儿子的函数？(不确定，ie调用儿子，firefox调用老子)
                    \end{itemize}
              \item 捕获与冒泡
                    \begin{itemize}
                        \item 捕获说先调用爸爸的监听函数
                        \item 冒泡说先调用儿子的监听函数
                    \end{itemize}
              \item W3C事件模型
                    \begin{itemize}
                        \item 先捕获(先爸爸=>儿子)再冒泡(再儿子=>爸爸)
                        \item 注意e对象被传给所有监听函数
                        \item 事业结束后，e对象就不存在了
                    \end{itemize}
          \end{itemize}
    \item target v.s. currentTarget
          \begin{itemize}
              \item 区别
                    \begin{itemize}
                        \item e.target - 用户操作的元素
                        \item e.currentTarget - 程序员监听的元素
                        \item this是e.currentTarget, 我个人不推荐使用它
                    \end{itemize}
              \item 举例
                    \begin{itemize}
                        \item div > span\{文字\}，用户点击文字
                        \item e.target就是span
                        \item e.currentTarget就是div
                    \end{itemize}
          \end{itemize}
    \item 一个特例
          \begin{itemize}
              \item 背景
                    \begin{itemize}
                        \item 只有一个div被监听(不考虑父子同时被监听)
                        \item fn分别在捕获阶段和冒泡阶段监听click事件
                        \item 用户点击的元素就是开发者监听的
                    \end{itemize}
              \item 代码
                    \begin{itemize}
                        \item
                              \begin{lstlisting}              
                            div.addEventListener('click', f1)
                        \end{lstlisting}
                        \item
                              \begin{lstlisting}              
                            div.addEventListener('click', f2, true)  
                        \end{lstlisting}
                        \item 请问，f1先执行还是f2先执行？
                        \item 如果把两行调换位置后，请问哪个先执行？
                        \item 错误答案：f2先执行
                        \item 正确答案: 谁先监听谁先执行
                        \item 总结：这是一个特例
                    \end{itemize}
          \end{itemize}
    \item 取消冒泡
          \begin{itemize}
              \item \orange{捕获不可以取消，但冒泡可以}
              \item e.stopPropagation()可中断冒泡，浏览器不再向上走
              \item 通俗来说：有人打我，我自己解决，别告诉我老子
              \item 一般用于封装某些独立的组件
          \end{itemize}
    \item 不可阻止默认动作
          \begin{itemize}
              \item \orange{有些事件不能阻止默认动作}
              \item MDN搜索scroll event，看到Bubbles和Cancelable
              \item Bubbles的意思是该事件是否冒泡，\green{所有冒泡都可取消}
              \item Cancelable的意思是开发者是否可以\red{阻止默认事件}
              \item \green{Cancelable与冒泡无关}
              \item 推荐看MDN英文版，中文版内容不全
                    \begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
                        \centering %图片居中
                        \includegraphics[width=0.7\textwidth]{image/cancel.png} %插入图片，[]中设置图片大小，{}中是图片文件名    
                    \end{figure}
          \end{itemize}
    \item 插曲：如何阻止滚动
          \begin{itemize}
              \item \orange{scroll事件}\red{不可阻止默认动作}
              \item 阻止scroll默认动作没用，因为先有滚动才有滚动事件
              \item 要阻止滚动，可阻止wheel和touchstart的默认动作
              \item 注意你需要找准滚动条所在的元素
              \item 但是如果用鼠标滚，滚动条还能用，可用CSS让滚动条 width: 0
              \item \orange{CSS也行}
              \item 使用overflow:hidden可以直接取消滚动条
              \item 但此时JS依然可以修改scrollTop
              \item \href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/stop-scroll}{\yellow{\underline{代码示例}}}
          \end{itemize}
    \item 小结
          \begin{itemize}
              \item \orange{target和currentTarget}
              \item 一个是用户点击的，一个是开发者监听的
              \item \orange{取消冒泡}
              \item e.stopPropagation()
              \item \orange{事件的特性}
              \item Bubbles表示是否冒泡
              \item Cancelable表示是否支持开发者取消冒泡
              \item 如scroll不支持取消冒泡
              \item \orange{如何禁用滚动}
              \item 取消特定元素的wheel和touchstart的默认动作，而不是阻止冒泡
          \end{itemize}
    \item 自定义事件
          \begin{itemize}
              \item 浏览器自带事件
                    \begin{itemize}
                        \item 一共100多种事件，\href{https://developer.mozilla.org/zh-CN/docs/Web/Events}{\red{\underline{列表}}}在MDN上
                    \end{itemize}
              \item 提问
                    \begin{itemize}
                        \item 开发者能不能在自带事件之外，自定义一个事件
                        \item 答：可以，见\href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/custom-event}{\yellow{\underline{示例}}}
                    \end{itemize}
          \end{itemize}
    \item 事件委托(装逼名词)
          \begin{itemize}
              \item 场景一
                    \begin{itemize}
                        \item 你要给100个按钮添加点击事件，咋办？
                        \item 答：监听这100个按钮的祖先，等冒泡的时候判断target是不是这100个按钮中的一个
                    \end{itemize}
              \item 场景二
                    \begin{itemize}
                        \item 你要监听目前不存在的元素的点击事件，咋办？
                        \item 答：监听祖先，等点击的时候看看是不是我想要监听的元素即可
                    \end{itemize}
              \item 优点
                    \begin{itemize}
                        \item 省监听数(内存)
                        \item 可以监听动态元素
                    \end{itemize}
              \item \href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/event-delegation}{\yellow{\underline{代码示例}}}
          \end{itemize}
    \item 封装事件委托
          \begin{itemize}
              \item 要求
                    \begin{itemize}
                        \item 写出这样一个函数
                              \begin{lstlisting}              
                                    on('click','#div1', 'button', fn)
                              \end{lstlisting}
                        \item 当用户点击\red{\#div1}里的\red{button}元素时，调用fn函数
                        \item 要求用到事件委托
                    \end{itemize}
              \item 答案一
                    \begin{itemize}
                        \item 判断target是否匹配的\red{button}
                        \item \href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/event-delegation}{\yellow{\underline{代码示例}}}
                        \item \red{注：}这样封装其实是错的，如果button里包span，点击的是span，当前元素不匹配button，就不执行
                        \item 所以只能用答案二里的递归操作
                    \end{itemize}
              \item 答案二
                    \begin{itemize}
                        \item 递归判断target/target的爸爸/target的爷爷
                        \item \href{https://github.com/syuancao/FrontNotePractice/tree/master/EVENT/event-delegation-encapsulation}{\yellow{\underline{代码示例}}}
                    \end{itemize}
              \item 整合进jQuery
                    \begin{itemize}
                        \item 有兴趣可以自己实现
                              \begin{lstlisting}              
                            $('#xxx').on('click', 'button', fn)
                      \end{lstlisting}
                    \end{itemize}
          \end{itemize}
    \item JS支持事件吗？
          \begin{itemize}
              \item \orange{答}
              \item 支持，也不支持。
              \item DOM事件不属于JS的功能，属于浏览器提供的DOM的功能
              \item JS只是调用了DOM提供的addEventListener而已
              \item \orange{追问}
              \item 如何让JS支持事件？请手写一个事件系统
              \item 目前水平可能写不出来，但可以先思考一段时间
          \end{itemize}
\end{enumerate}
\section{前端站点导航}
\begin{enumerate}
    \item 设计需要用到的网站
          \begin{itemize}
              \item \tiffany{https://www.figma.com/}
              \item \tiffany{https://www.iconfont.cn/}
          \end{itemize}
    \item 一些细节
          \begin{itemize}
              \item 引入jQuery用https://www.bootcdn.cn/
              \item background-color会自动填满整个页面
          \end{itemize}
\end{enumerate}
\section{前后分离}
\subsection{AJAX的原理}
\subsection{异步与Promise}
\subsection{跨域，CORS，JSONP}
\red{面试必必必问，菜逼必定不回答}
\begin{enumerate}
    \item 跨域关键知识
          \begin{itemize}
              \item \orange{同源策略}
              \item 浏览器故意设计的一个功能限制
              \item \orange{CORS}
              \item 突破浏览器限制的一个方法
              \item \orange{JSONP}
              \item IE时代的妥协
          \end{itemize}
    \item 同源的定义
          \begin{itemize}
              \item \orange{源}
              \item window.origin或location.origin可以得到当前源
              \item 源 = 协议 + 域名 + 端口号
              \item \orange{如果两个url的}
              \item 协议
              \item 域名
              \item 端口号
              \item 完全一致，那么这两个url就是同源
              \item \orange{举例}
              \item \url{https://qq.com}，\url{https://www.baidu.com} 不同源
              \item \url{https://baidu.com}，\url{https://www.baidu.com} 不同源
              \item 完全一致才算同源
          \end{itemize}
    \item 同源策略的定义
          \begin{itemize}
              \item \orange{浏览器规定}
              \item 如果JS\blue{运行在}源A里，那么就只能获取源A的数据
              \item 不能获取源B的数据，即\blue{不允许跨域}
              \item \orange{举例(省略http协议)}
              \item 假设syuancao.com/index.html引用了cdn.com/1.js
              \item 所以1.js就只能获取syuancao.com的数据
              \item 不能获取1.syuancao.com或者qq.com的数据
              \item \orange{这是浏览器的功能！}
              \item 浏览器故意要这样设计的
              \item \blue{同源策略就是不同源的页面之间，不准互相访问数据}
          \end{itemize}
    \item 浏览器这样做的目的是啥？
          \begin{itemize}
              \item 为了保护用户隐私！怎么保护的？
          \end{itemize}
    \item 如果没有同源策略
          \begin{itemize}
              \item \orange{以QQ空间为例}
              \item 源为\url{https://user.qzone.qq.com}
              \item 假设，当前用户已经登录 (用Cookie，后面讲)
              \item 假设，AJAX请求/friends.json可获取用户好友列表
              \item 到目前为止都很正常
              \item \orange{黑客来了}
              \item 假设你的女神分享了\url{https://qzone-qq.com}给你
              \item 实际上这个是一个钓鱼网站
              \item 你点开这个网页，这样网页也请求你的好友列表
              \item \url{https://user.qzone.qq.com/friends.json}
              \item 请问，你的好友列表是不是就把黑客偷偷偷走了？
              \item 好像是哦......
          \end{itemize}
    \item 问题的根源
          \begin{itemize}
              \item \orange{无法区分发送者}
              \item QQ空间页面里的JS和黑客网页里的JS
              \item 发的请求几乎没有区别(referrer有区别)
              \item 所以，没有同源策略，任何页面都能偷QQ空间的数据
              \item 甚至支付宝余额！
              \item \orange{那检查referer不就号了？}
              \item 安全原则：安全链条的强度取决于最弱的一环
              \item 万一这个网站的后端开发工程师是个傻X呢
              \item 所以浏览器应该主动预防这个偷数据的行为
              \item 总之，浏览器为了用户隐私，设置了严格的同源策略
          \end{itemize}
    \item 代码演示步骤
          \begin{itemize}
              \item \orange{创建目录}
              \item qq-com里面有一个server.js，用来模拟QQ空间
              \item syuancao-com里面有一个server.js，用来模拟坏人网站
              \item \orange{qq-com}
              \item /index.html是首页
              \item /qq.js是JS脚本文件
              \item /friends.json是模拟的好友数据
              \item 端口监听为8888，访问\url{http://127.0.0.1:8888}
              \item \orange{syuancao-com}
              \item /index.html是首页
              \item /syuancao.js是JS脚本文件
              \item 端口监听为9999，访问\url{http://127.0.0.1:9999}
          \end{itemize}
    \item hosts
          \begin{itemize}
              \item \orange{设置本地域名映射}
              \item 让qq.com映射到127.0.0.1
              \item 就可以访问\url{http://qq.com:8888/index.html}
              \item 让syuancao.com映射到127.0.0.1
              \item 就可以访问\url{http://syuancao.com:9999/index.html}
              \item \orange{设置hosts}
              \item 让两个\url{http://127.0.0.1}变成不同的
          \end{itemize}
    \item 跨域AJAX
          \begin{itemize}
              \item \orange{正常使用AJAX}
              \item 在qq.com:8888里运行的JS可以访问/friends.json
              \item \orange{黑客偷数据}
              \item 在syuancao.com:9999里运行的JS不能访问！
              \item 浏览器需要\blue{CORS}
              \item \orange{提问}
              \item 黑客的请求成功了没有？
              \item 答: 成功了，因为qq.com后台有log
              \item 黑客拿到了响应没有？
              \item 答：没有，因为浏览器不给数据给它
              \item 就没有浏览器不限制跨域么？
              \item 答：如果不限制，就是浏览器bug了，快向浏览器反馈
          \end{itemize}
    \item 其他新手疑问
          \begin{itemize}
              \item \orange{为什么a.qq.com访问qq.com也算跨域？}
              \item 答：因为历史上出现过不同公司的共用域名，这两个不一定是同一网站
              \item 浏览器为了谨慎起见，认为这是不同的源
              \item \orange{为什么不同端口也算跨域？}
              \item 答：原因同上，一个端口一个公司。记住安全链条的强度取决于最弱的一环
              \item 任何给安全相关的问题都要谨慎对待
              \item \orange{为什么两个网站的IP是一样的，也算跨域？}
              \item 答: 原因同上，IP可以公用。
              \item \orange{为什么可以跨域使用CSS，JS和图片等？}
              \item 答：同源策略限制的是数据访问，我们引用CSS,JS和图片的时候，其实并不知道
              \item 其内容，我们只是在引用。不信我问你，你能知道CSS的第一个字符是什么吗？
              \item \orange{现实却是：请问怎么跨域？}
              \item 面试官会问你，工作中也会遇到
          \end{itemize}
    \item 解法一: CORS
          \begin{itemize}
              \item \orange{问题根源}
              \item 浏览器默认不同源之间不能互相访问数据
              \item 但是qq.com和syuancao.com其实都是方方的网站
              \item 方方就是想要两个网站互相访问，浏览器为什么阻止
              \item \orange{好吧，用CORS}
              \item 浏览器说，如果要共享数据，需要提前声明！
              \item 哦，那怎么声明呢？
              \item 浏览器说，qq.com在响应头里写syuancao.com可以访问
              \item 哦，具体语法呢？
              \item Access-Control-Allow-Origin:http://foo.example
              \item 浏览器说：都在MDN文档里
              \item 注意：CORS分为假单请求和复杂请求，具体看文档
          \end{itemize}
    \item 解法二: JSONP (可兼容IE)
          \begin{itemize}
              \item \orange{定义}
              \item JSONP和JSON半毛线关系都没有
              \item 由于前端水平低下，错误地将其称为JSONP
              \item 具体看代码
              \item \orange{我们现在面临地问题是什么？}
              \item 程序员常常面临奇葩需求
              \item 没有CORS，怎么跨域
              \item 记不记得我们可以随意引用JS
              \item 虽然我们不能访问qq.com:8888/friends.json
              \item 但是我们能用qq.com:8888/friends.js啊！
              \item 这有哦什么用？JS又不是数据
              \item 我们让JS包含数据不就好了。。。
              \item 试试看吧！明天就要上线啦！
          \end{itemize}
    \item JSONP步骤
          \begin{itemize}
              \item \orange{syuancao.com访问qq.com}
              \item qq.com将数据写到/friends.js
              \item syuancao.com用script标签引用/friends.js
              \item /friend.js执行，执行什么呢？
              \item syuancao事先定义号window.xxx函数
              \item /friend.js执行window.xxx({friends:[...]})
              \item 然后syuancao.com就是通过window.xxx获取到数据了
              \item window.xxx就是一个回调啊！
              \item 这TM都能想到，人才啊！
              \item 这是很多前端工程师一起想出来的
          \end{itemize}
    \item 优化
          \begin{itemize}
              \item \orange{xxx能不写死吗？}
              \item window.xxx能不能改其他名字？
              \item 其实名字不重要，只要syuancao.com定义的函数名
              \item 和qq.com/friends.js执行的函数名是同一个即可！
              \item 那就把名字传给/friends.js
              \item 具体看代码
          \end{itemize}
    \item 再优化
          \begin{itemize}
              \item \orange{封装！}
              \item 初级程序员学API，中级程序员学封装
              \item 封装成jsonp('url').then(f1, f2)
          \end{itemize}
    \item JSONP是什么？(面试回答，需要回答优缺点)
          \begin{itemize}
              \item JSONP就是我们在跨域的时候由于当前浏览器不支持CORS
              \item 或者因为某些条件不支持CORS，我们必须使用另外一种方式
              \item 来跨域，于是我们就请求一个JS文件，这个JS文件会执行一个回调，
              \item 回调里面就有我们的数据。回调的名字是可以随机生成的，给个随机数
              \item 然后我们把这个名字以callback的名字传给后台，
              \item 后台会把这个函数返回给我们并执行。
              \item JSONP优点是兼容IE，也可以成功跨域。
              \item JSONP缺点是因为它是script标签，读不到AJAX那么精确的状态，不知道
              \item 状态码和成功的头是什么，只知道响应和失败。
              \item 由于它是script标签，所以它只能发get请求，即JSONP不支持post
          \end{itemize}
    \item \href{https://github.com/syuancao/FrontNotePractice/tree/master/CROSS-ORIGIN}{\yellow{\underline{代码示例}}}
\end{enumerate}
\subsection{静态服务器}
\subsection{Ajax实战：Cookie，Session}
\section{MVC}
\section{Webpack}
\section{虚拟DOM与DOM diff}
\section{Vue}
\section{React}
\section{NodeJS}
\section{Vue3造轮子}

\end{document}